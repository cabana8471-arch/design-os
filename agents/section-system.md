# Section System

This document covers file structure, view relationships, and the skills & design guidance system.

---

## File Structure

> **Note:** Empty directories in the boilerplate contain `.gitkeep` placeholder files. See "Template State (Boilerplate Directories)" section in `export-handoff.md` for details. These placeholders are omitted from the diagram for clarity.

```
.claude/
├── commands/                      # Executable commands for Design OS
│   └── design-os/                 # Design OS workflow commands
│       ├── design-screen.md
│       ├── design-shell.md
│       ├── export-product.md
│       ├── product-interview.md
│       ├── product-vision.md
│       ├── product-roadmap.md
│       ├── data-model.md
│       ├── design-tokens.md
│       ├── sample-data.md
│       ├── screenshot-design.md
│       └── shape-section.md
│
├── skills/                        # Specialized guidance for design quality
│   └── frontend-design/           # Guidance for high-quality UI components
│       └── SKILL.md               # Comprehensive design guidance
│
└── templates/                     # Modular prompt templates
    └── design-os/
        ├── README.md              # Template system documentation
        ├── common/                # Templates used in both prompt types
        ├── one-shot/              # One-shot implementation prompts
        └── section/               # Section-specific prompts

product/                           # Product definition (portable)
├── product-context.md             # Comprehensive product context from interview
├── product-overview.md            # Product description, problems/solutions, features
├── product-roadmap.md             # List of sections with titles and descriptions
│
├── data-model/                    # Global data model
│   └── data-model.md              # Entity descriptions and relationships
│
├── design-system/                 # Design tokens
│   ├── colors.json                # { primary, secondary, neutral }
│   └── typography.json            # { heading, body, mono }
│
├── shell/                         # Application shell
│   ├── spec.md                    # Shell specification (includes Shell Relationships)
│   ├── data.json                  # Sample data for shell components
│   └── types.ts                   # TypeScript interfaces for shell
│
└── sections/
    └── [section-id]/
        ├── spec.md                # Section specification
        ├── data.json              # Sample data for screen designs
        ├── types.ts               # TypeScript interfaces
        └── *.png                  # Screenshots

src/
├── shell/                         # Shell design components
│   ├── components/
│   │   │
│   │   │ # --- Primary (created by /design-shell) ---
│   │   ├── AppShell.tsx           # Main shell wrapper (always created)
│   │   ├── MainNav.tsx            # Navigation component (always created)
│   │   ├── UserMenu.tsx           # User menu component (always created)
│   │   │
│   │   │ # --- Secondary (generated if selected) ---
│   │   ├── NotificationsDrawer.tsx # (if notifications selected)
│   │   ├── SearchModal.tsx        # Command palette (if search selected)
│   │   ├── SettingsModal.tsx      # Settings form (if settings selected)
│   │   ├── ProfileModal.tsx       # Profile editor (if profile selected)
│   │   ├── HelpPanel.tsx          # Help drawer (if help selected)
│   │   ├── FeedbackModal.tsx      # Feedback form (if feedback selected)
│   │   ├── MobileMenuDrawer.tsx   # Mobile nav drawer (if mobile selected)
│   │   │
│   │   │ # --- Pre-existing utilities (in boilerplate) ---
│   │   ├── SkipLink.tsx           # Skip-to-content accessibility link
│   │   ├── ShellErrorBoundary.tsx # Error boundary for secondary components
│   │   ├── LogoArea.tsx           # Customizable logo/branding area
│   │   ├── ThemeToggle.tsx        # Light/dark/system theme switcher
│   │   ├── ShellSkeleton.tsx      # Loading skeleton states
│   │   ├── ShellFooter.tsx        # Optional footer with version/links
│   │   │
│   │   └── index.ts               # Exports all components
│   ├── hooks/                     # Shell utility hooks
│   │   └── index.ts               # Exports all hooks
│   └── index.ts                   # Main shell module export

└── sections/
    └── [section-id]/
        ├── components/            # Exportable components (see note below)
        │   ├── [Component].tsx
        │   └── index.ts
        └── [ViewName].tsx         # Preview wrapper (see note below)

product-plan/                      # Export package (GENERATED by /export-product)
├── README.md                      # Quick start guide
├── product-overview.md            # Product summary
├── design-guidance/               # Design guidance for implementation
│   └── frontend-design.md         # Frontend design principles
├── prompts/                       # Ready-to-use prompts for coding agents
├── instructions/                  # Implementation instructions
├── design-system/                 # Tokens, colors, fonts
├── data-model/                    # Types and sample data
├── shell/                         # Shell components
└── sections/
    └── [section-id]/
        ├── components/            # Exportable React components
        ├── sample-data.json       # Test data (copied from data.json)
        ├── types.ts               # Section-specific types
        ├── README.md              # Section implementation guide
        └── tests.md               # TDD test specifications
```

### Shell Component Categories

| Category      | Created By                    | Examples                                              | Exported to product-plan? |
| ------------- | ----------------------------- | ----------------------------------------------------- | ------------------------- |
| **Primary**   | `/design-shell` (always)      | AppShell, MainNav, UserMenu                           | Yes                       |
| **Secondary** | `/design-shell` (if selected) | NotificationsDrawer, SearchModal, SettingsModal, etc. | Yes                       |
| **Utility**   | Pre-existing in boilerplate   | SkipLink, ShellErrorBoundary, ThemeToggle             | No (Design OS internal)   |

> **Key Distinction:** Primary and Secondary components are GENERATED for the product design and get exported. Utility components are BOILERPLATE infrastructure for Design OS previews — they're not part of the export package.

### Components vs. Preview Wrappers

| Type                      | Location                      | Purpose                                               | Exported? |
| ------------------------- | ----------------------------- | ----------------------------------------------------- | --------- |
| **Exportable Components** | `components/[Component].tsx`  | Props-based UI components that receive data via props | Yes       |
| **Preview Wrappers**      | `[ViewName].tsx` (root level) | Design OS preview files that load sample data         | No        |

**Example:**

```
src/sections/invoices/
├── components/
│   ├── InvoiceList.tsx    ← Exportable: receives `invoices` prop, renders list
│   ├── InvoiceCard.tsx    ← Exportable: receives `invoice` prop, renders card
│   └── index.ts           ← Re-exports all components
└── InvoiceListView.tsx    ← Preview wrapper: loads data.json, passes to InvoiceList
```

The preview wrapper imports sample data and provides it to components for Design OS viewing. The exportable components never import data directly — they accept everything via props.

> **Preview Naming Convention:** Shell uses `ShellPreview.tsx` (noun only) while sections use `[ViewName]View.tsx` (noun + View suffix). This is intentional:
>
> - **Shell** — Single preview file wraps the entire shell; "Preview" suffix distinguishes it from the AppShell component
> - **Sections** — Multiple preview files per section (one per view); "View" suffix distinguishes previews from exportable components in the same folder

### data.json → sample-data.json Transformation

| Phase  | File Name          | Location                      | Purpose                       |
| ------ | ------------------ | ----------------------------- | ----------------------------- |
| Design | `data.json`        | `product/sections/[id]/`      | Design OS preview data        |
| Export | `sample-data.json` | `product-plan/sections/[id]/` | Implementation test/seed data |

**When:** The rename happens during `/export-product` (Step 9: Copy and Transform Components).

**Why:** In the target codebase, "sample-data" clarifies this is test/seed data for development, not production data.

---

## Naming Conventions

| Type             | Convention                  | Example            |
| ---------------- | --------------------------- | ------------------ |
| Section ID       | kebab-case                  | `user-management`  |
| Component files  | PascalCase.tsx              | `UserList.tsx`     |
| Type files       | kebab-case.ts               | `types.ts`         |
| Data files       | kebab-case.json             | `data.json`        |
| View components  | PascalCase + View suffix    | `UserListView.tsx` |
| Preview wrappers | PascalCase + Preview suffix | `ShellPreview.tsx` |

> **Section ID Rules**: See `validation-patterns.md` Section ID Generation Rules for complete naming requirements.

---

## Component Folder Organization

### Standard Section Structure

```
src/sections/[section-id]/
├── components/           # Exportable components
│   ├── index.ts         # Barrel export
│   ├── [Primary].tsx    # Main view component
│   ├── [Secondary].tsx  # Detail/form components
│   └── [Shared].tsx     # Shared within section
└── [ViewName]View.tsx   # Preview wrappers (not exported)
```

### When to Create Sub-folders

| Condition       | Action           |
| --------------- | ---------------- |
| <5 components   | Flat structure   |
| 5-10 components | Group by feature |
| >10 components  | Split section    |

### Index.ts Pattern

```tsx
// components/index.ts
export { UserList } from "./UserList";
export { UserCard } from "./UserCard";
export { UserForm } from "./UserForm";
// Do NOT export preview wrappers
```

---

## View Relationships

Design OS supports wiring views together for functional previews. When a section has multiple views (e.g., list + drawer), they can be connected so clicking an item in the list actually opens the drawer.

### Defining Relationships in spec.md

The `/shape-section` command (Step 4.6) asks about view relationships and stores them in the spec:

> **Note on step numbers:** Step numbers like "Step 4.6" use decimal notation to indicate sub-steps within a major workflow phase. These refer to steps within the command file itself (e.g., `.claude/commands/design-os/shape-section.md`). Check the command file for the complete step breakdown.

```markdown
## View Relationships

- AgentListView.onView -> AgentDetailDrawer (drawer, entityId)
- AgentListView.onCreate -> CreateAgentModal (modal, none)
```

**Format:** `- [PrimaryView].[callback] -> [SecondaryView] ([type], [dataRef])`

### Relationship Types

| Type     | UI Component       | Use Case                                  |
| -------- | ------------------ | ----------------------------------------- |
| `drawer` | `<Sheet>`          | Side panel for details, editing           |
| `modal`  | `<Dialog>`         | Centered overlay for forms, confirmations |
| `inline` | Conditional render | Expand in place, accordion-style          |

### Data References

| Ref        | Description                                          | Example                         |
| ---------- | ---------------------------------------------------- | ------------------------------- |
| `entityId` | Callback receives ID, secondary view looks up entity | `onView?: (id: string) => void` |
| `entity`   | Full entity passed directly                          | Less common                     |
| `none`     | No data (create forms)                               | `onCreate?: () => void`         |

### How It Works

1. **`/shape-section`** — Asks about view relationships, saves to spec.md
2. **`/sample-data`** — Generates Props interfaces for both primary and secondary views
3. **`/design-screen`** — Creates all related views together + wired preview wrapper
4. **Preview** — Click works! Opens drawer/modal with actual content

### Wired Preview Pattern

Instead of `console.log` callbacks, wired previews use state:

```tsx
// Wired preview wrapper (Design OS only)
export default function AgentListPreview() {
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  const [selectedId, setSelectedId] = useState<string | null>(null);

  const selectedAgent = selectedId
    ? data.agents.find((a) => a.id === selectedId)
    : null;

  return (
    <>
      <AgentList
        agents={data.agents}
        onView={(id) => {
          setSelectedId(id);
          setIsDrawerOpen(true);
        }}
      />
      <Sheet open={isDrawerOpen} onOpenChange={setIsDrawerOpen}>
        <SheetContent>
          {selectedAgent && <AgentDetailDrawer agent={selectedAgent} />}
        </SheetContent>
      </Sheet>
    </>
  );
}
```

### Backwards Compatibility

Sections without `## View Relationships`:

- Continue to work with `console.log` callbacks
- No automatic wiring attempted
- Upgrade by adding the section to spec.md and re-running `/design-screen`

### Export Behavior

View relationships are documented but preview wrappers are NOT exported:

- Relationship info goes in section README.md
- Implementation patterns included as guidance
- Actual wiring depends on target codebase's state management

---

## Skills & Design Guidance

Design OS includes a skills system that provides specialized guidance for creating high-quality screen designs.

### The Frontend-Design Skill

The **frontend-design** skill provides comprehensive guidance for creating distinctive, production-grade frontend interfaces that avoid generic "AI-generated" aesthetics.

**Location:** `.claude/skills/frontend-design/SKILL.md`

**File Format:** The SKILL.md file uses a custom format:

```
<!-- v1.0.0 -->
<!-- Usage: description... -->

name: skill-name
description: skill description

---

[Actual guidance content]
```

Note: The `name:` and `description:` fields are NOT inside YAML frontmatter — they appear before the `---` separator. This is intentional for readability.

**When to Use:**

- Referenced by `/design-shell` command — before creating shell components
- Referenced by `/design-screen` command — before creating section screen designs

**What It Covers:**

- Creating distinctive UI that reflects your product's visual identity
- Choosing bold design directions and unexpected layouts
- Applying thoughtful typography and color choices
- Using motion and transitions effectively
- Avoiding generic fonts (Inter, Roboto), predictable layouts, and "AI slop" aesthetics

### How Skills Integrate with Commands

Commands that create user-facing components reference the frontend-design skill to ensure design quality:

1. **`/design-shell`** — Creates application shell components
   - Step 1: Validates `.claude/skills/frontend-design/SKILL.md` exists and has meaningful content (>100 chars)
   - Step 5: Applies the design guidance (preparation for component creation)
   - Step 7: Creates AppShell, MainNav, UserMenu components using the applied guidance

2. **`/design-screen`** — Creates section screen designs
   - Step 1: Validates `.claude/skills/frontend-design/SKILL.md` exists and has meaningful content (>100 chars)
   - Step 5: Applies the design guidance when creating screen components

### Skill File Content Template

**Required Structure for SKILL.md:**

```markdown
<!-- v1.0.0 -->
<!-- Usage: [when to use this skill] -->

name: [skill-name]
description: [one-line description]

---

## [Main Guidance Section]

[Actual guidance content - minimum 100 characters after metadata]

### Sub-section 1

[Detailed guidance]

### Sub-section 2

[More guidance]
```

**Validation Criteria:**

1. Version comment present (e.g., `<!-- v1.0.0 -->`)
2. `name:` and `description:` fields before `---`
3. Content after `---` separator
4. Minimum 100 characters of actual guidance
5. At least one markdown heading (##)

### Design Guidance Hierarchy

When creating screen designs, follow this hierarchy:

1. **Technical Requirements** (agents.md, Design Requirements section) — MANDATORY
   - Mobile responsive (Tailwind responsive prefixes)
   - Light/dark mode support (dark: variants)
   - Props-based components (portable, no direct data imports)
   - Tailwind CSS v4 (not v3)

2. **Aesthetic Guidance** (frontend-design skill) — STRONGLY RECOMMENDED
   - Distinctive visual identity
   - Bold design directions
   - Thoughtful typography and color choices
   - Effective use of motion
   - If unavailable, commands use Enhanced Fallback Design Guidance (see below)

### Skill File Validation Pattern

Commands that reference the frontend-design skill must validate the skill file before use:

**Validation Steps:**

1. **Check existence:** Verify `.claude/skills/frontend-design/SKILL.md` exists
2. **Check content:** File must have at least 100 characters after stripping metadata and whitespace
3. **Check structure:** File should contain design guidance sections

**Validation Script:**

```bash
SKILL_FILE=".claude/skills/frontend-design/SKILL.md"

if [ ! -f "$SKILL_FILE" ]; then
  echo "Skill file missing"
else
  CONTENT_LENGTH=$(sed '/^---$/,/^---$/d' "$SKILL_FILE" | tr -d '[:space:]' | wc -c)
  if [ "$CONTENT_LENGTH" -lt 100 ]; then
    echo "Skill file has insufficient content"
  else
    echo "Skill file valid"
  fi
fi
```

### Enhanced Fallback Design Guidance

When the skill file is unavailable, use these enhanced fallback principles.

> **REQUIRED:** When SKILL.md is unavailable, asking the user to select an aesthetic tone is MANDATORY before proceeding with design.

**Aesthetic Tone Options** (REQUIRED — ask user to choose one):

- **Refined Utility**: Clean, purposeful, subtle shadows, muted accents, professional feel
- **Bold & Bright**: High contrast, vibrant colors, strong typography, energetic
- **Soft & Approachable**: Rounded corners, pastel accents, generous spacing, friendly
- **Professional Dense**: Compact layout, neutral palette, efficient use of space, data-focused

**Visual Hierarchy:**

- Create clear distinction using size, weight, AND color together
- Use generous whitespace around primary actions
- Group related elements with subtle background colors
- Apply contrast intentionally to guide the eye

**Color Application:**

- Primary: Reserve for key actions and active states
- Secondary: Use for supportive elements
- Neutral: Create hierarchy with 3-4 distinct shades
- Accent: One unexpected color choice for distinctiveness

**Typography Choices:**

- Headings: Slightly heavier weight (600-700), moderate tracking
- Body: Regular weight (400), comfortable line height (1.5-1.7)
- Use size differences of at least 4px between hierarchy levels
- Consider one distinctive font choice

**Motion & Interaction:**

- Prefer CSS transitions over JavaScript animations
- Use 150-200ms for hover states
- Use 250-300ms for entry/exit animations
- Avoid bounce or overshoot effects unless matching a playful tone

**Distinctiveness Requirement:**
Even without the full skill file, make at least ONE distinctive choice:

- An unexpected color accent
- Asymmetric layout element
- Creative use of negative space
- Unique hover interaction
- Non-standard card treatment

---

## Performance Guidelines

### Component Complexity Limits

| Metric      | Limit   | Action if Exceeded        |
| ----------- | ------- | ------------------------- |
| Props       | <15     | Split into sub-components |
| Lines       | <300    | Extract logic to hooks    |
| Re-renders  | <10/sec | Add useMemo/useCallback   |
| Bundle size | <50KB   | Code-split large deps     |

### Data Optimization

- Paginate lists >50 items
- Virtualize lists >100 items
- Debounce search inputs (300ms)
- Cache API responses when appropriate

### Image Guidelines

- Use WebP format
- Lazy load below-fold images
- Provide width/height to prevent layout shift

---

## Testing Screen Designs

### Unit Test Structure

```tsx
describe("UserListView", () => {
  it("renders user list", () => {
    render(<UserListView users={mockUsers} />);
    expect(screen.getByRole("list")).toBeInTheDocument();
  });

  it("calls onSelectUser when item clicked", () => {
    const onSelect = vi.fn();
    render(<UserListView users={mockUsers} onSelectUser={onSelect} />);
    fireEvent.click(screen.getByText("John Doe"));
    expect(onSelect).toHaveBeenCalledWith("user-1");
  });

  it("shows empty state when no users", () => {
    render(<UserListView users={[]} />);
    expect(screen.getByText(/no users/i)).toBeInTheDocument();
  });
});
```

### What to Test

- [ ] Renders with mock data
- [ ] All callbacks fire correctly
- [ ] Empty states display
- [ ] Loading states display
- [ ] Error states display
- [ ] Responsive breakpoints work

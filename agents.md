# Agent Directives for Design OS

Design OS is a **product planning and design tool** that helps users define their product vision, structure their data model, design their UI, and prepare export packages for implementation in a separate codebase.

> **Important**: Design OS is a planning tool, not the end product codebase. The screen designs and components generated here are meant to be exported and integrated into your actual product's codebase.

---

## Understanding Design OS Context

When working in Design OS, be aware of two distinct contexts:

### 1. Design OS Application

The React application that displays and manages planning files. When modifying the Design OS UI itself:

- Files live in `src/` (components, pages, utilities)
- Uses the Design OS design system (stone palette, DM Sans, etc.)
- Provides the interface for viewing specs, screen designs, exports, etc.

### 2. Product Design (Screen Designs & Exports)

The product you're planning and designing. When creating screen designs and exports:

- Screen design components live in `src/sections/[section-id]/` and `src/shell/`
- Product definition files live in `product/`
- Exports are packaged to `product-plan/` for integration into a separate codebase
- Follow the design requirements specified in each section's spec

---

## Language Requirement

**All files generated by Design OS commands MUST be in English**, regardless of the conversation language:

- **Product specifications**: `product-overview.md`, `product-roadmap.md`, `spec.md`
- **Code files**: `types.ts`, React components, `data.json`
- **Documentation**: Comments, README files, handoff docs
- **Sample data**: Labels, descriptions, and placeholder text

**Why this matters:**

1. **Consistency** — All generated files use the same language
2. **Portability** — Exports work with any developer or coding agent
3. **Industry standard** — Technical documentation and code are written in English

**Note:** The conversation with the user can be in any language, but all _generated files_ must be in English.

---

## Getting Started — The Planning Flow

Design OS follows a structured planning sequence:

### 0. Product Interview (`/product-interview`) — REQUIRED

Gather comprehensive context about your product through a structured interview. This creates `product/product-context.md` which is **required** by all subsequent commands.

**Output:** `product/product-context.md`

**Modes:**

- Default — Full interview (12 categories, ~52 questions)
- `--minimal` — Quick start (6 critical categories, meets 50% threshold)
- `--stage=X` — Focus on specific area (vision, section, shell, data, scale, quality)
- `--audit` — Check completeness of existing context
- `--skip-validation` — Bypass existing context check (for advanced users updating context)

### 0.5. Audit Context (`/audit-context`) — RECOMMENDED

Critical analysis of `product/product-context.md` to identify issues before proceeding with implementation. Detects quality problems, inconsistencies, logic conflicts, ambiguities, and duplications.

**Output:** `product/audit-report.md`

**Workflow:**

1. Run `/audit-context` after `/product-interview`
2. Review issues in report
3. Fix issues in `product-context.md`
4. Re-run `/audit-context` until 0 HIGH issues
5. Proceed with `/product-vision`

### 1. Product Overview (`/product-vision`)

Define your product's core description, the problems it solves, and key features.
**Output:** `product/product-overview.md`

### 2. Product Roadmap (`/product-roadmap`)

Break your product into 3-5 development sections. Each section represents a self-contained area that can be designed and built independently.
**Output:** `product/product-roadmap.md`

### 3. Data Model (`/data-model`)

Define the core entities and relationships in your product. This establishes the "nouns" of your system and ensures consistency across sections.
**Output:** `product/data-model/data-model.md`

### 4. Design System (`/design-tokens`)

Choose your color palette (from Tailwind) and typography (from Google Fonts). These tokens are applied to all screen designs.
**Output:** `product/design-system/colors.json`, `product/design-system/typography.json`

### 5. Application Shell (`/design-shell`)

Design the persistent navigation and layout that wraps all sections.
**Output:** `product/shell/spec.md`, `product/design-system/design-direction.md`, `src/shell/components/`

### 6. For Each Section:

- `/shape-section` — Define the specification
- `/sample-data` — Create sample data and types
- `/design-screen` — Create screen designs
- `/screenshot-design` — Capture screenshots

### 7. Export (`/export-product`)

Generate the complete export package with all components, types, and handoff documentation.
**Output:** `product-plan/`

---

## Command Quick Reference

### Files Generated Per Command

| Command              | Creates                                                                                                                                                                                                                                                       | Location                         |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------- |
| `/product-interview` | `product-context.md`                                                                                                                                                                                                                                          | `product/`                       |
| `/audit-context`     | `audit-report.md`                                                                                                                                                                                                                                             | `product/`                       |
| `/product-vision`    | `product-overview.md`                                                                                                                                                                                                                                         | `product/`                       |
| `/product-roadmap`   | `product-roadmap.md`                                                                                                                                                                                                                                          | `product/`                       |
| `/data-model`        | `data-model.md`                                                                                                                                                                                                                                               | `product/data-model/`            |
| `/design-tokens`     | `colors.json`, `typography.json` [2]                                                                                                                                                                                                                          | `product/design-system/`         |
| `/design-shell`      | `spec.md`, `data.json`, `types.ts`, `design-direction.md`, Primary components (`AppShell.tsx`, `MainNav.tsx`, `UserMenu.tsx`), Secondary components (based on selection: `NotificationsDrawer.tsx`, `SearchModal.tsx`, `SettingsModal.tsx`, etc.), `index.ts` | See note below [1]               |
| `/shape-section`     | `spec.md`                                                                                                                                                                                                                                                     | `product/sections/[section-id]/` |
| `/sample-data`       | `data.json`, `types.ts`                                                                                                                                                                                                                                       | `product/sections/[section-id]/` |
| `/design-screen`     | `[ViewName].tsx`, `components/*.tsx`, `components/index.ts`                                                                                                                                                                                                   | `src/sections/[section-id]/`     |
| `/screenshot-design` | `[view-name].png`                                                                                                                                                                                                                                             | `product/sections/[section-id]/` |
| `/export-product`    | Complete export package                                                                                                                                                                                                                                       | `product-plan/`                  |

**[1] /design-shell file locations:**

- `spec.md`, `data.json`, `types.ts` → `product/shell/`
- `design-direction.md` → `product/design-system/`
- Primary components (`AppShell.tsx`, `MainNav.tsx`, `UserMenu.tsx`) → `src/shell/components/`
- Secondary components (if selected in Step 3.6) → `src/shell/components/`
- `index.ts` → `src/shell/components/`
- `ShellPreview.tsx` → `src/shell/` (Generated by `/design-shell`, Design OS only, not exported)

**[2] /design-tokens typography requirement:** `typography.json` MUST include a `mono` font field for code/data display. If not specified by user, defaults to IBM Plex Mono.

### Command Prerequisites

| Command              | Required                                                          | Optional                                    |
| -------------------- | ----------------------------------------------------------------- | ------------------------------------------- |
| `/product-interview` | —                                                                 | —                                           |
| `/audit-context`     | `product-context.md`                                              | —                                           |
| `/product-vision`    | `product-context.md` (≥50%)                                       | —                                           |
| `/product-roadmap`   | `product-context.md`, `product-overview.md`                       | —                                           |
| `/data-model`        | `product-context.md`, `product-overview.md`, `product-roadmap.md` | —                                           |
| `/design-tokens`     | `product-context.md`, `product-overview.md`                       | —                                           |
| `/design-shell`      | `product-context.md`, `product-overview.md`, `product-roadmap.md` | Design tokens, Sections, `SKILL.md`         |
| `/shape-section`     | `product-context.md`, `product-overview.md`, `product-roadmap.md` | Data model, Shell spec                      |
| `/sample-data`       | `product-context.md`, Section `spec.md`                           | Data model                                  |
| `/design-screen`     | `product-context.md`, Section `spec.md`, `data.json`, `types.ts`  | Design tokens, Shell components, `SKILL.md` |
| `/screenshot-design` | Screen design components                                          | Playwright MCP                              |
| `/export-product`    | `product-context.md`, `product-overview.md`, at least one section | Shell components, All sections              |

**Legend:**

- **Required**: Command will STOP if missing
- **Optional**: Command will WARN and continue with defaults if missing

**Note on Design Tokens for /design-shell:** While design tokens are optional, if they don't exist, `/design-shell` will use default stone/lime colors. For product-specific branding, run `/design-tokens` before `/design-shell`.

> **Relationship to /audit-context Command Readiness:** The table above shows FILE prerequisites (what files must exist). The `/audit-context` command has a separate "Command Readiness" table showing CATEGORY completeness requirements. A command needs BOTH: the required files must exist AND the relevant categories must have sufficient content.
>
> **Quick Reference:** See `.claude/commands/design-os/audit-context.md` Step 8.2 for the complete Command Readiness table that maps commands to required category completeness levels.

### Step Numbering Convention

Design OS commands use decimal step notation for granularity:

| Notation     | Meaning                             | Example                           |
| ------------ | ----------------------------------- | --------------------------------- |
| `Step N`     | Major workflow phase                | Step 1: Check Prerequisites       |
| `Step N.M`   | Sub-step within phase               | Step 3.6: Ask about relationships |
| `Step 0.N`   | Audit/pre-check steps (conditional) | Step 0.5: Audit existing shell    |
| `Step NA`    | Conditional branch                  | Step 8A: Shell validation         |
| `Step N-N.M` | Range of steps (inclusive)          | Step 0-0.7: All audit steps       |

**Range Notation:** `Step 0-0.7` refers to discrete steps in that range (e.g., Steps 0, 0.5, 0.6, 0.7), not a continuous mathematical range. The actual steps included depend on what's defined in the command file.

**Examples from /design-shell:**

- Step 0-0.7: Audit steps — includes Step 0, 0.5, 0.6, 0.7 (discrete sub-steps)
- Step 1-2: Prerequisite checks — includes Step 1, 2 (two major steps)
- Step 3.1-3.6: Shell configuration questions — includes Steps 3.1, 3.2, 3.3, 3.4, 3.5, 3.6
- Step 6.5: Create design-direction.md
- Step 7: Create components

**Cross-Command References:**

When referencing steps in other commands, use format: `/[command] Step N.M`

Example: "See `/design-shell` Step 6.5 for design direction creation"

> **Maintenance Note:** When modifying step numbers in a command file, search for references to those steps in agents.md and other command files. Use grep: `grep -r "Step [number]" .claude/` to find all references that may need updating.

---

## File Structure

> **Note:** Empty directories in the boilerplate contain `.gitkeep` placeholder files. See "The .gitkeep Convention" section below for details. These placeholders are omitted from the diagram for clarity.

```
.claude/
├── commands/                      # Executable commands for Design OS
│   └── design-os/                 # Design OS workflow commands
│       ├── design-screen.md
│       ├── design-shell.md
│       ├── export-product.md
│       ├── product-interview.md
│       ├── product-vision.md
│       ├── product-roadmap.md
│       ├── data-model.md
│       ├── design-tokens.md
│       ├── sample-data.md
│       ├── screenshot-design.md
│       └── shape-section.md
│
├── skills/                        # Specialized guidance for design quality
│   └── frontend-design/           # Guidance for high-quality UI components
│       └── SKILL.md               # Comprehensive design guidance
│
└── templates/                     # Modular prompt templates
    └── design-os/
        ├── README.md              # Template system documentation
        ├── common/                # Templates used in both prompt types
        │   ├── top-rules.md
        │   ├── reporting-protocol.md
        │   ├── model-guidance.md
        │   ├── verification-checklist.md
        │   ├── clarifying-questions.md
        │   └── tdd-workflow.md
        ├── one-shot/              # One-shot implementation prompts
        │   ├── preamble.md
        │   └── prompt-template.md
        └── section/               # Section-specific prompts
            ├── preamble.md
            ├── prompt-template.md
            ├── clarifying-questions.md
            └── tdd-workflow.md

product/                           # Product definition (portable)
├── product-context.md             # Comprehensive product context from interview
├── product-overview.md            # Product description, problems/solutions, features
├── product-roadmap.md             # List of sections with titles and descriptions
│
├── data-model/                    # Global data model
│   └── data-model.md              # Entity descriptions and relationships
│
├── design-system/                 # Design tokens
│   ├── colors.json                # { primary, secondary, neutral }
│   └── typography.json            # { heading, body, mono }
│
├── shell/                         # Application shell
│   ├── spec.md                    # Shell specification (includes Shell Relationships)
│   ├── data.json                  # Sample data for shell components
│   └── types.ts                   # TypeScript interfaces for shell
│
└── sections/
    └── [section-id]/
        ├── spec.md                # Section specification
        ├── data.json              # Sample data for screen designs
        ├── types.ts               # TypeScript interfaces
        └── *.png                  # Screenshots

**data.json → sample-data.json Transformation:**

| Phase | File Name | Location | Purpose |
|-------|-----------|----------|---------|
| Design | `data.json` | `product/sections/[id]/` | Design OS preview data |
| Export | `sample-data.json` | `product-plan/sections/[id]/` | Implementation test/seed data |

**When:** The rename happens during `/export-product` (Step 9: Copy and Transform Components).

**Why:** In the target codebase, "sample-data" clarifies this is test/seed data for development, not production data. The file contains realistic examples for UI testing and component development.

src/
├── shell/                         # Shell design components
│   ├── components/
│   │   │
│   │   │ # --- Primary (created by /design-shell) ---
│   │   ├── AppShell.tsx           # Main shell wrapper (always created)
│   │   ├── MainNav.tsx            # Navigation component (always created)
│   │   ├── UserMenu.tsx           # User menu component (always created)
│   │   │
│   │   │ # --- Secondary (generated if selected) ---
│   │   ├── NotificationsDrawer.tsx # (if notifications selected)
│   │   ├── SearchModal.tsx        # Command palette (if search selected)
│   │   ├── SettingsModal.tsx      # Settings form (if settings selected)
│   │   ├── ProfileModal.tsx       # Profile editor (if profile selected)
│   │   ├── HelpPanel.tsx          # Help drawer (if help selected)
│   │   ├── FeedbackModal.tsx      # Feedback form (if feedback selected)
│   │   ├── MobileMenuDrawer.tsx   # Mobile nav drawer (if mobile selected)
│   │   │
│   │   │ # --- Pre-existing utilities (in boilerplate) ---
│   │   ├── SkipLink.tsx           # Skip-to-content accessibility link
│   │   ├── ShellErrorBoundary.tsx # Error boundary for secondary components
│   │   ├── LogoArea.tsx           # Customizable logo/branding area
│   │   ├── ThemeToggle.tsx        # Light/dark/system theme switcher
│   │   ├── ShellSkeleton.tsx      # Loading skeleton states
│   │   ├── ShellFooter.tsx        # Optional footer with version/links
│   │   │
│   │   └── index.ts               # Exports all components
│   ├── hooks/                     # Shell utility hooks
│   │   └── index.ts               # Exports all hooks
│   └── index.ts                   # Main shell module export

**Shell Component Categories:**

| Category | Created By | Examples | Exported to product-plan? |
|----------|------------|----------|---------------------------|
| **Primary** | `/design-shell` (always) | AppShell, MainNav, UserMenu | Yes |
| **Secondary** | `/design-shell` (if selected in Step 3.6) | NotificationsDrawer, SearchModal, SettingsModal, etc. | Yes |
| **Utility** | Pre-existing in boilerplate | SkipLink, ShellErrorBoundary, ThemeToggle, ShellSkeleton | No (Design OS internal) |

> **Key Distinction:** Primary and Secondary components are GENERATED for the product design and get exported. Utility components are BOILERPLATE infrastructure for Design OS previews — they're not part of the export package.

> **Note on ThemeToggle:** ThemeToggle appears in both categories. The **Utility** version (pre-existing in boilerplate) provides basic theme switching for Design OS previews. If selected in `/design-shell` Step 3.6, a **Secondary** ThemeToggle is generated with product-specific styling and exported. The generated version replaces the utility version in the export package.

> **See also:** "Shell Utility Components" section below for detailed list of pre-existing utility components and hooks.

└── sections/
    └── [section-id]/
        ├── components/            # Exportable components (see note below)
        │   ├── [Component].tsx
        │   └── index.ts
        └── [ViewName].tsx         # Preview wrapper (see note below)

**Components vs. Preview Wrappers:**

| Type | Location | Purpose | Exported? |
|------|----------|---------|-----------|
| **Exportable Components** | `components/[Component].tsx` | Props-based UI components that receive data via props. These are portable and meant to be copied to your production codebase. | Yes — copied to `product-plan/sections/[id]/components/` |
| **Preview Wrappers** | `[ViewName].tsx` (root of section folder) | Design OS preview files that load sample data and pass it to exportable components. Used only for viewing designs in the browser. | No — these stay in Design OS only |

**Example:**
```

src/sections/invoices/
├── components/
│ ├── InvoiceList.tsx ← Exportable: receives `invoices` prop, renders list
│ ├── InvoiceCard.tsx ← Exportable: receives `invoice` prop, renders card
│ └── index.ts ← Re-exports all components
└── InvoiceListView.tsx ← Preview wrapper: loads data.json, passes to InvoiceList

```

The preview wrapper imports sample data and provides it to components for Design OS viewing. The exportable components never import data directly — they accept everything via props.

> **Preview Naming Convention:** Shell uses `ShellPreview.tsx` (noun only) while sections use `[ViewName]View.tsx` (noun + View suffix). This is intentional:
>
> - **Shell** — Single preview file wraps the entire shell; "Preview" suffix distinguishes it from the AppShell component
> - **Sections** — Multiple preview files per section (one per view); "View" suffix distinguishes previews from exportable components in the same folder

**Seeing Examples:**
- Run the Design OS workflow commands (`/product-vision`, `/shape-section`, etc.) to generate real examples
- Check the `docs/` directory for walkthroughs and guides:
  - `docs/getting-started.md` — Quick start guide
  - `docs/product-planning.md` — Product vision and roadmap workflow
  - `docs/design-section.md` — Section design workflow
  - `docs/export.md` — Export and handoff process
  - `docs/codebase-implementation.md` — Implementation guidance
- Each command's step-by-step output shows exactly what files are created

product-plan/                      # Export package (GENERATED by /export-product)
├── README.md                      # Quick start guide
├── product-overview.md            # Product summary
├── design-guidance/               # Design guidance for implementation
│   └── frontend-design.md         # Frontend design principles (copied from SKILL.md in Step 7)
├── prompts/                       # Ready-to-use prompts for coding agents
│   ├── one-shot-prompt.md         # Prompt for full implementation
│   └── section-prompt.md          # Prompt template for incremental
├── instructions/                  # Implementation instructions
│   ├── one-shot-instructions.md   # All milestones combined
│   └── incremental/               # Milestone-by-milestone instructions
│       ├── 01-foundation.md
│       └── [NN]-[section-id].md   # Section-specific instructions (starting at 02)
├── design-system/                 # Tokens, colors, fonts
├── data-model/                    # Types and sample data
│   ├── types.ts                   # Consolidated TypeScript interfaces
│   ├── README.md                  # Data model documentation
│   └── sample-data.json           # Combined sample data from all sections
├── shell/                         # Shell components
│   ├── components/                # AppShell.tsx, MainNav.tsx, UserMenu.tsx, index.ts
│   └── README.md                  # Shell usage documentation
└── sections/
    └── [section-id]/
        ├── components/            # Exportable React components
        ├── sample-data.json       # Test data (copied from data.json)
        ├── types.ts               # Section-specific types
        ├── README.md              # Section implementation guide
        └── tests.md               # TDD test specifications
```

---

## Design Requirements

When creating screen designs, follow these guidelines:

- **Mobile Responsive**: Use Tailwind's responsive prefixes (`sm:`, `md:`, `lg:`, `xl:`) to ensure layouts adapt properly across screen sizes. Note: Section components use mobile-first design; shell components use desktop-first. See "Responsive Strategy Clarification" section for details.

- **Light & Dark Mode**: Use `dark:` variants for all colors. Test that all UI elements are visible and readable in both modes.

- **Use Design Tokens**: When design tokens are defined, apply the product's color palette and typography. Otherwise, fall back to `stone` for neutrals and `lime` for accents.

- **Props-Based Components**: All screen design components must accept data and callbacks via props. Never import data directly in exportable components.

- **No Navigation in Section Screen Designs**: Section screen designs should not include navigation chrome. The shell handles all navigation.

---

## Content Container Standard

All section screen designs MUST use a consistent container wrapper. This ensures visual harmony across sections.

### Container Pattern

```tsx
<div className="h-full bg-[neutral]-50 dark:bg-[neutral]-950 px-4 py-4 sm:px-6">
  {/* Section content */}
</div>
```

> **Note:** `[neutral]` is a placeholder — replace with your neutral color palette (e.g., `stone`, `slate`, `gray`, `zinc`). For example: `bg-stone-50 dark:bg-stone-950`.

### Container Values by Information Density

| Density     | Container Padding   | Background           |
| ----------- | ------------------- | -------------------- |
| Compact     | `px-3 py-3 sm:px-4` | `bg-[neutral]-50/50` |
| Comfortable | `px-4 py-4 sm:px-6` | `bg-[neutral]-50`    |
| Spacious    | `px-6 py-6 sm:px-8` | `bg-[neutral]-50`    |

### Where Density Comes From

1. **design-direction.md** — If exists, use the documented Information Density value
2. **Existing sections** — If no design-direction, match existing section patterns
3. **Default** — If neither exists, use "Comfortable" (`px-4 py-4 sm:px-6`)

### Edge-to-Edge Exception

Some views require full-width content (dashboards, maps, large visualizations). In these cases:

1. Still wrap in `<div className="h-full bg-[neutral]-50">`
2. Apply padding only to header/control areas
3. Document the exception with a comment

```tsx
// Edge-to-edge layout for dashboard charts
<div className="h-full bg-stone-50 dark:bg-stone-950">
  <div className="px-4 sm:px-6 py-4 border-b">
    {/* Header with standard padding */}
  </div>
  <div className="flex-1">{/* Full-width chart area */}</div>
</div>
```

---

## Tailwind CSS Directives

These rules apply to both the Design OS application and all screen designs/components it generates:

- **Tailwind CSS v4**: We always use Tailwind CSS v4 (not v3). Do not reference or create v3 patterns.

- **No tailwind.config.js**: Tailwind CSS v4 does not use a `tailwind.config.js` file. Never reference, create, or modify one.

- **Use Built-in Utility Classes**: Avoid writing custom CSS. Stick to using Tailwind's built-in utility classes for all styling.

- **Use Built-in Colors**: Avoid defining custom colors. Use Tailwind's built-in color utility classes (e.g., `stone-500`, `lime-400`, `red-600`).

### Tailwind v4 Specific Patterns

Design OS uses Tailwind CSS v4, which has several differences from v3:

| Feature         | v3 Pattern                    | v4 Pattern                            |
| --------------- | ----------------------------- | ------------------------------------- |
| Configuration   | `tailwind.config.js`          | CSS-based via `@import "tailwindcss"` |
| Theme Extension | `extend: { colors: {...} }`   | `@theme { --color-* }` in CSS         |
| Dark Mode       | `darkMode: 'class'`           | Built-in, automatic                   |
| Content Paths   | `content: ['./src/**/*.tsx']` | Automatic detection                   |
| Plugins         | `plugins: [...]` in config    | CSS `@plugin` directive               |

**Key v4 behaviors in Design OS:**

- Theme tokens defined in `src/index.css` using `@theme` block
- Dark mode toggles `dark` class on `<html>` element
- Colors use Tailwind's built-in palette (no custom tokens)
- Typography uses Google Fonts loaded via CSS `@import`

**Migration notes for developers:**

- Never create `tailwind.config.js` — it's not used in v4
- Custom colors go in `@theme { --color-custom: #value }` not config
- The `@apply` directive still works for composing utilities
- JIT mode is always on — no need to enable it

---

## Import Path Aliases

Design OS uses TypeScript path aliases for cleaner imports. The `@/` alias maps to `./src/*`.

### Configuration

Defined in `tsconfig.json`:

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

### Usage Examples

| Instead of                                                   | Use                                                      |
| ------------------------------------------------------------ | -------------------------------------------------------- |
| `import { Button } from '../../../components/ui/button'`     | `import { Button } from '@/components/ui/button'`        |
| `import { loadSectionData } from '../../lib/section-loader'` | `import { loadSectionData } from '@/lib/section-loader'` |
| `import type { SectionData } from '../types/section'`        | `import type { SectionData } from '@/types/section'`     |

### When to Use

- **Always use `@/`** for imports from `src/` — cleaner and path-independent
- **Use relative imports** only within the same directory (e.g., `./Button.tsx`)
- **Barrel exports** (index.ts files) can use relative imports for their directory

### Consistency Rules

1. Components in `src/components/` import utilities from `@/lib/`
2. Pages import components from `@/components/`
3. Types are always imported from `@/types/`
4. UI primitives are imported from `@/components/ui/`

---

## The Four Pillars

Design OS is organized around four main areas:

1. **Product Overview** — The "what" and "why"
   - Product name and description
   - Problems and solutions
   - Key features
   - Sections/roadmap

2. **Data Model** — The "nouns" of the system
   - Core entity names and descriptions
   - Relationships between entities
   - Minimal — leaves room for implementation

3. **Design System** — The "look and feel"
   - Color palette (Tailwind colors)
   - Typography (Google Fonts)

4. **Application Shell** — The persistent chrome
   - Global navigation structure
   - User menu
   - Layout pattern

Plus **Sections** — The individual features, each with spec, data, screen designs.

---

## Skills & Design Guidance

Design OS includes a skills system that provides specialized guidance for creating high-quality screen designs.

### The Frontend-Design Skill

The **frontend-design** skill provides comprehensive guidance for creating distinctive, production-grade frontend interfaces that avoid generic "AI-generated" aesthetics.

**Location:** `.claude/skills/frontend-design/SKILL.md`

**File Format:** The SKILL.md file uses a custom format:

```
<!-- v1.0.0 -->
<!-- Usage: description... -->

name: skill-name
description: skill description

---

[Actual guidance content]
```

Note: The `name:` and `description:` fields are NOT inside YAML frontmatter — they appear before the `---` separator. This is intentional for readability.

> **Why this format?** Standard YAML frontmatter (between two `---` lines) is parsed as metadata and often hidden by editors. By placing `name:` and `description:` BEFORE the `---`, they remain visible when reading the file directly. The `---` then separates metadata from the actual guidance content. To parse this format, read lines before the first `---` for metadata, and everything after for content.

**When to Use:**

- Referenced by `/design-shell` command — before creating shell components
- Referenced by `/design-screen` command — before creating section screen designs

**What It Covers:**

- Creating distinctive UI that reflects your product's visual identity
- Choosing bold design directions and unexpected layouts
- Applying thoughtful typography and color choices
- Using motion and transitions effectively
- Avoiding generic fonts (Inter, Roboto), predictable layouts, and "AI slop" aesthetics

### How Skills Integrate with Commands

Commands that create user-facing components reference the frontend-design skill to ensure design quality:

1. **`/design-shell`** — Creates application shell components
   - Step 1: Validates `.claude/skills/frontend-design/SKILL.md` exists and has meaningful content (>100 chars)
   - Step 5: Applies the design guidance (preparation for component creation)
   - Step 7: Creates AppShell, MainNav, UserMenu components using the applied guidance
   - Ensures shell has distinctive, branded aesthetics matching the product vision

2. **`/design-screen`** — Creates section screen designs
   - Step 1: Validates `.claude/skills/frontend-design/SKILL.md` exists and has meaningful content (>100 chars)
   - Step 5: Applies the design guidance when creating screen components
   - Ensures consistent, distinctive design quality across all sections

### Design Guidance Hierarchy

When creating screen designs, follow this hierarchy:

1. **Technical Requirements** (agents.md, Design Requirements section) — MANDATORY
   - Mobile responsive (Tailwind responsive prefixes)
   - Light/dark mode support (dark: variants)
   - Props-based components (portable, no direct data imports)
   - Tailwind CSS v4 (not v3)

2. **Aesthetic Guidance** (frontend-design skill) — STRONGLY RECOMMENDED
   - Distinctive visual identity
   - Bold design directions
   - Thoughtful typography and color choices
   - Effective use of motion
   - If unavailable, commands use Enhanced Fallback Design Guidance (see below)

Both should be followed for production-ready screen designs. Technical requirements ensure portability and consistency; aesthetic guidance ensures distinctive, memorable design.

### Skill File Validation Pattern

Commands that reference the frontend-design skill (`/design-shell`, `/design-screen`) must validate the skill file before use:

**Validation Steps:**

1. **Check existence:** Verify `.claude/skills/frontend-design/SKILL.md` exists
2. **Check content:** File must have at least 100 characters after stripping metadata and whitespace (roughly 2-3 short paragraphs of actual guidance)
3. **Check structure:** File should contain design guidance sections

> **What counts as "meaningful":** 100 chars is the minimum threshold to ensure the file isn't just boilerplate. A proper skill file should have at least 500+ chars covering aesthetic principles, typography choices, and color philosophy.

**Validation Script:**

```bash
# Check skill file exists and has meaningful content (excluding metadata)
SKILL_FILE=".claude/skills/frontend-design/SKILL.md"

if [ ! -f "$SKILL_FILE" ]; then
  echo "Skill file missing"
else
  # Strip metadata section (content between --- markers) and whitespace before counting
  CONTENT_LENGTH=$(sed '/^---$/,/^---$/d' "$SKILL_FILE" | tr -d '[:space:]' | wc -c)
  if [ "$CONTENT_LENGTH" -lt 100 ]; then
    echo "Skill file has insufficient content"
  else
    echo "Skill file valid"
  fi
fi
```

**Fallback Behavior:**

If the skill file is missing or empty, commands should:

1. Warn the user (design may be more generic)
2. Offer to continue with basic design principles
3. Proceed with fallback guidance if user approves

This ensures commands don't fail completely when the skill file is missing, while still encouraging its use for better results.

**Standard Reference in Commands:**

Commands that use the skill file should include this validation as an early step (typically Step 1):

```markdown
## Step 1: Validate Skill File

Before creating screen designs, validate the frontend-design skill file:

1. Check if `.claude/skills/frontend-design/SKILL.md` exists
2. Verify it has at least 100 characters of content
3. If valid, proceed to use it in [Step N where design is applied]
4. If missing/empty, ask user: "Continue with basic design principles?"

See: agents.md → "Skill File Validation Pattern" for the standard validation script.
```

**Commands that MUST validate the skill file:**

- `/design-shell` — Before creating AppShell, MainNav, UserMenu components
- `/design-screen` — Before creating section screen design components

**Commands that do NOT require skill file validation:**

- `/product-vision`, `/product-roadmap`, `/data-model` — No visual design created
- `/sample-data` — Data only, no visual components
- `/screenshot-design` — Captures existing designs, doesn't create new ones
- `/export-product` — Packages existing components, doesn't create new ones

### Skill Invocation Standard Pattern

Commands that reference the frontend-design skill MUST follow this standardized pattern for consistency:

**Step A: Validate (Early in command — typically Step 1)**

```bash
SKILL_FILE=".claude/skills/frontend-design/SKILL.md"
SKILL_AVAILABLE=false

if [ ! -f "$SKILL_FILE" ]; then
  echo "Warning: Skill file missing at $SKILL_FILE"
elif [ $(sed '/^---$/,/^---$/d' "$SKILL_FILE" | tr -d '[:space:]' | wc -c) -lt 100 ]; then
  echo "Warning: Skill file has insufficient content (< 100 chars)"
else
  SKILL_AVAILABLE=true
  echo "Skill file validated"
fi
```

**Step B: Apply (Before creating components — typically Step 5)**

If SKILL_AVAILABLE is true:

1. Read `.claude/skills/frontend-design/SKILL.md`
2. Extract and apply "Design Thinking" and "Frontend Aesthetics Guidelines" sections
3. Ensure distinctive, non-generic design choices

If SKILL_AVAILABLE is false:

1. Use enhanced fallback design principles (see below)
2. Inform user that design may be more generic
3. Document that fallback was used

**Step C: Document (After creating components)**

Record design decisions in `design-direction.md` (created by `/design-shell`):

- Aesthetic tone chosen
- Key visual signatures applied
- Color/typography treatments used

This ensures future `/design-screen` runs can maintain consistency.

### Enhanced Fallback Design Guidance

When the skill file is unavailable, use these enhanced fallback principles that include aesthetic direction (not just mechanical rules).

> **REQUIRED:** When SKILL.md is unavailable, asking the user to select an aesthetic tone is MANDATORY before proceeding with design. Do not skip this step or use a default tone without user input. This ensures the design has intentional aesthetic direction rather than being generic.

**Aesthetic Tone Options** (REQUIRED — ask user to choose one):

- **Refined Utility**: Clean, purposeful, subtle shadows, muted accents, professional feel
- **Bold & Bright**: High contrast, vibrant colors, strong typography, energetic
- **Soft & Approachable**: Rounded corners, pastel accents, generous spacing, friendly
- **Professional Dense**: Compact layout, neutral palette, efficient use of space, data-focused

**Visual Hierarchy** (beyond just sizes):

- Create clear distinction using size, weight, AND color together
- Use generous whitespace around primary actions
- Group related elements with subtle background colors
- Apply contrast intentionally to guide the eye

**Color Application**:

- Primary: Reserve for key actions and active states (buttons, links, selected items)
- Secondary: Use for supportive elements (badges, highlights, secondary buttons)
- Neutral: Create hierarchy with 3-4 distinct shades (not more)
- Accent: One unexpected color choice for distinctiveness

**Typography Choices**:

- Headings: Slightly heavier weight (600-700), moderate tracking
- Body: Regular weight (400), comfortable line height (1.5-1.7)
- Use size differences of at least 4px between hierarchy levels
- Consider one distinctive font choice (avoid Inter, Roboto unless product specifically requires them)

**Motion & Interaction**:

- Prefer CSS transitions over JavaScript animations
- Use 150-200ms for hover states
- Use 250-300ms for entry/exit animations
- Avoid bounce or overshoot effects unless matching a playful tone

**Distinctiveness Requirement**:
Even without the full skill file, make at least ONE distinctive choice:

- An unexpected color accent
- Asymmetric layout element
- Creative use of negative space
- Unique hover interaction
- Non-standard card treatment

---

## View Relationships

Design OS supports wiring views together for functional previews. When a section has multiple views (e.g., list + drawer), they can be connected so clicking an item in the list actually opens the drawer.

### Defining Relationships in spec.md

The `/shape-section` command (Step 4.6) asks about view relationships and stores them in the spec:

> **Note on step numbers:** Step numbers like "Step 4.6" use decimal notation to indicate sub-steps within a major workflow phase. These refer to steps within the command file itself (e.g., `.claude/commands/design-os/shape-section.md`). Check the command file for the complete step breakdown.

```markdown
## View Relationships

- AgentListView.onView -> AgentDetailDrawer (drawer, entityId)
- AgentListView.onCreate -> CreateAgentModal (modal, none)
```

**Format:** `- [PrimaryView].[callback] -> [SecondaryView] ([type], [dataRef])`

### Relationship Types

| Type     | UI Component       | Use Case                                  |
| -------- | ------------------ | ----------------------------------------- |
| `drawer` | `<Sheet>`          | Side panel for details, editing           |
| `modal`  | `<Dialog>`         | Centered overlay for forms, confirmations |
| `inline` | Conditional render | Expand in place, accordion-style          |

### Data References

| Ref        | Description                                          | Example                         |
| ---------- | ---------------------------------------------------- | ------------------------------- |
| `entityId` | Callback receives ID, secondary view looks up entity | `onView?: (id: string) => void` |
| `entity`   | Full entity passed directly                          | Less common                     |
| `none`     | No data (create forms)                               | `onCreate?: () => void`         |

### How It Works

1. **`/shape-section`** — Asks about view relationships, saves to spec.md
2. **`/sample-data`** — Generates Props interfaces for both primary and secondary views
3. **`/design-screen`** — Creates all related views together + wired preview wrapper
4. **Preview** — Click works! Opens drawer/modal with actual content

### Wired Preview Pattern

Instead of `console.log` callbacks, wired previews use state:

```tsx
// Wired preview wrapper (Design OS only)
export default function AgentListPreview() {
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  const [selectedId, setSelectedId] = useState<string | null>(null);

  const selectedAgent = selectedId
    ? data.agents.find((a) => a.id === selectedId)
    : null;

  return (
    <>
      <AgentList
        agents={data.agents}
        onView={(id) => {
          setSelectedId(id);
          setIsDrawerOpen(true);
        }}
      />
      <Sheet open={isDrawerOpen} onOpenChange={setIsDrawerOpen}>
        <SheetContent>
          {selectedAgent && <AgentDetailDrawer agent={selectedAgent} />}
        </SheetContent>
      </Sheet>
    </>
  );
}
```

### Backwards Compatibility

Sections without `## View Relationships`:

- Continue to work with `console.log` callbacks
- No automatic wiring attempted
- Upgrade by adding the section to spec.md and re-running `/design-screen`

### Export Behavior

View relationships are documented but preview wrappers are NOT exported:

- Relationship info goes in section README.md
- Implementation patterns included as guidance
- Actual wiring depends on target codebase's state management

---

## Shell Relationships

Similar to View Relationships for sections, Shell Relationships wire interactive shell elements (header actions, user menu items) to their corresponding secondary components (drawers, modals).

### Defining Relationships in shell spec.md

The `/design-shell` command (Step 3.6) asks about interactive elements and stores relationships in the spec.

> **Note on step references:** Step numbers use decimal notation (e.g., "Step 3.6", "Step 6.5") to indicate sub-steps or refinements within major workflow phases. The integer part indicates the major step, and the decimal indicates a sub-step within that phase. These refer to steps within the command file itself (e.g., `.claude/commands/design-os/design-shell.md`). Check the command file for the complete step breakdown.

```markdown
## Shell Relationships

- HeaderAction.notifications -> NotificationsDrawer (drawer, notifications)
- HeaderAction.search -> SearchModal (modal, none)
- HeaderAction.help -> HelpPanel (drawer, helpTopics)
- HeaderAction.theme -> ThemeToggle (inline, none)
- UserMenu.profile -> ProfileModal (modal, user)
- UserMenu.settings -> SettingsModal (modal, settings)
- UserMenu.feedback -> FeedbackModal (modal, none)
- MobileNav.toggle -> MobileMenuDrawer (drawer, none)
```

**Format:** `- [Trigger].[action] -> [Component] ([type], [dataRef])`

> **Important:** The `- ` prefix (hyphen + space) is REQUIRED for markdown list parsing. Lines without this prefix will be ignored by the relationship parser.

### Trigger Types

| Trigger        | Source                   | Example Action                    |
| -------------- | ------------------------ | --------------------------------- |
| `HeaderAction` | Header toolbar buttons   | `notifications`, `search`, `help` |
| `UserMenu`     | User dropdown menu items | `profile`, `settings`, `feedback` |
| `MobileNav`    | Mobile navigation        | `toggle`                          |

### Relationship Types

| Type     | UI Component  | Use Case                                        |
| -------- | ------------- | ----------------------------------------------- |
| `drawer` | `<Sheet>`     | Side panel for notifications, help, mobile menu |
| `modal`  | `<Dialog>`    | Centered overlay for search, settings, profile  |
| `inline` | Direct render | Theme toggle button rendered directly in header |

### Data References

| Ref             | Description                       | Props Interface                   |
| --------------- | --------------------------------- | --------------------------------- |
| `notifications` | Notification list from shell data | `NotificationsDrawerProps`        |
| `user`          | User profile data                 | `ProfileModalProps`               |
| `settings`      | Settings configuration            | `SettingsModalProps`              |
| `helpTopics`    | Help documentation                | `HelpPanelProps`                  |
| `none`          | No data needed (just callbacks)   | Component-specific callbacks only |

**Data Structure Examples (from `product/shell/data.json`):**

```json
{
  "notifications": [
    {
      "id": "n1",
      "title": "New message",
      "read": false,
      "timestamp": "2024-01-15T10:30:00Z"
    }
  ],
  "user": {
    "id": "u1",
    "name": "Jane Smith",
    "email": "jane@example.com",
    "avatar": "/avatars/jane.jpg"
  },
  "settings": {
    "theme": "system",
    "notifications": true,
    "language": "en"
  }
}
```

### How It Works

1. **`/design-shell` Step 3.6** — Asks about interactive elements, records selections
2. **`/design-shell` Step 6.6** — Adds `## Shell Relationships` to spec.md
3. **`/design-shell` Step 6.7-6.8** — Creates `data.json` and `types.ts` for shell
4. **`/design-shell` Step 7** — Creates secondary components based on selections
5. **`/design-shell` Step 8** — Creates wired ShellPreview with state management
6. **Preview** — Click works! Opens drawer/modal with actual data

### Wired Shell Preview Pattern

ShellPreview uses state to wire handlers instead of console.log:

```tsx
// Wired shell preview (Design OS only)
export default function ShellPreview() {
  const [isNotificationsOpen, setIsNotificationsOpen] = useState(false);
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  // ... state for each secondary component

  return (
    <>
      <AppShell
        onHeaderAction={(actionId) => {
          if (actionId === "notifications") setIsNotificationsOpen(true);
          if (actionId === "search") setIsSearchOpen(true);
        }}
        onProfileClick={() => setIsProfileOpen(true)}
        // ... other wired handlers
      >
        {/* Content */}
      </AppShell>

      <Sheet open={isNotificationsOpen} onOpenChange={setIsNotificationsOpen}>
        <SheetContent>
          <NotificationsDrawer
            notifications={data.notifications}
            onClose={() => setIsNotificationsOpen(false)}
            // ... other props
          />
        </SheetContent>
      </Sheet>

      {/* ... other secondary components */}
    </>
  );
}
```

### Shell Data & Types

**`product/shell/data.json`** — Sample data for secondary components:

```json
{
  "_meta": {
    "description": "Sample data for shell interactive components",
    "generatedBy": "/design-shell",
    "models": {
      "notifications": "List of user notifications",
      "user": "Current user profile",
      "settings": "User preferences"
    }
  },
  "notifications": [...],
  "user": {...},
  "settings": {...}
}
```

**`product/shell/types.ts`** — TypeScript interfaces for all shell components.

### Keyboard Shortcuts

When SearchModal is selected, ShellPreview wires keyboard shortcuts:

- **Cmd+K / Ctrl+K** — Opens search modal
- **Escape** — Closes any open modal/drawer

### Export Behavior

Shell relationships are documented but ShellPreview is NOT exported:

- Secondary components are exported to `product-plan/shell/components/`
- Shell README.md documents the relationships
- Wiring implementation depends on target codebase's state management

### Relationship Format Standard

Both View Relationships (sections) and Shell Relationships use the same format:

```
- [Source].[callback] -> [Target] ([type], [dataRef])
```

| Component | View Relationships                              | Shell Relationships                                    |
| --------- | ----------------------------------------------- | ------------------------------------------------------ |
| Source    | View component name (e.g., `AgentListView`)     | Trigger type (`HeaderAction`, `UserMenu`, `MobileNav`) |
| callback  | Handler name (`onView`, `onCreate`)             | Action name (`notifications`, `search`, `profile`)     |
| Target    | Secondary component (e.g., `AgentDetailDrawer`) | Secondary component (e.g., `NotificationsDrawer`)      |
| type      | `drawer`, `modal`, `inline`                     | `drawer`, `modal`, `inline`                            |
| dataRef   | `entityId`, `entity`, `none`                    | `notifications`, `user`, `settings`, `none`            |

The `- ` prefix is required in spec.md files for markdown list parsing.

---

## Design Direction Document

The Design Direction document captures aesthetic decisions made during shell design and ensures consistency across all sections.

### Purpose

1. **Document decisions**: Record the aesthetic choices made when applying the frontend-design skill
2. **Enable consistency**: Provide a reference for `/design-screen` to match shell aesthetics
3. **Guide implementation**: Help implementation agents understand the intended visual identity

### Location

`product/design-system/design-direction.md`

### Schema

```markdown
# Design Direction for [Product Name]

## User Preferences

| Setting                 | Choice                                                |
| ----------------------- | ----------------------------------------------------- |
| **Aesthetic Tone**      | Professional / Modern / Minimal / Playful / Technical |
| **Animation Style**     | None / Subtle / Standard / Rich                       |
| **Information Density** | Compact / Comfortable / Spacious                      |
| **Responsive Priority** | Desktop-first / Mobile-first / Balanced               |

## Aesthetic Tone

[One sentence describing the overall feel - e.g., "Refined utility with bold lime accents"]

## Visual Signatures

These distinctive elements MUST appear consistently across all sections:

- [Signature 1 - e.g., "Rounded corners (rounded-xl) on all cards"]
- [Signature 2 - e.g., "Lime-500 accent for primary actions"]
- [Signature 3 - e.g., "Stone-900 dark backgrounds with high contrast text"]

## Color Application

- **Primary usage**: [When and how - e.g., "Lime for buttons, active nav, key CTAs"]
- **Accent pattern**: [How accents draw attention - e.g., "Subtle lime underlines on hover"]
- **Neutral treatment**: [How neutrals create hierarchy - e.g., "Stone-50 to stone-900 for depth"]

## Motion & Interaction

- **Animation style**: [subtle/bold/none]
- **Key interactions**: [e.g., "200ms ease-out for all hover states"]
- **Timing**: [e.g., "Fast - prioritize responsiveness over flair"]

## Typography Treatment

- **Heading style**: [e.g., "DM Sans 600, tight tracking, stone-900"]
- **Body approach**: [e.g., "DM Sans 400, relaxed line-height, stone-600"]
- **Distinctive choices**: [e.g., "Mono font for data values and IDs"]

## Consistency Guidelines

These rules MUST remain consistent across all sections:

1. [Guideline - e.g., "All interactive elements use lime-500 hover states"]
2. [Guideline - e.g., "Card padding is always p-6"]
3. [Guideline - e.g., "Dark mode uses stone-900 backgrounds, not black"]

## Applied From

- **Skill file used**: [Yes/No - whether SKILL.md was used]
- **Fallback tone**: [If fallback, which tone was chosen]
```

### Created By

The `/design-shell` command creates this document in Step 6.5, after defining the shell spec and before creating components.

### Design Direction Lifecycle

| Phase  | Command           | Step     | Action                                              |
| ------ | ----------------- | -------- | --------------------------------------------------- |
| Create | `/design-shell`   | Step 6.5 | Creates `product/design-system/design-direction.md` |
| Read   | `/design-screen`  | Step 2   | Reads for aesthetics consistency                    |
| Apply  | `/design-screen`  | Step 5   | Applies guidance to screen components               |
| Export | `/export-product` | Step 7   | Copies to `product-plan/design-system/`             |

### Command References

| Command           | How It Uses design-direction.md                            |
| ----------------- | ---------------------------------------------------------- |
| `/design-shell`   | **Creates** the document (Step 6.5)                        |
| `/design-screen`  | **Reads and applies** aesthetics (Steps 2, 5)              |
| `/shape-section`  | Does NOT reference (spec is functional, not visual)        |
| `/sample-data`    | Does NOT reference (data structure, not presentation)      |
| `/design-tokens`  | Does NOT reference (tokens are inputs TO design-direction) |
| `/export-product` | **Copies** to export package                               |

> **Note:** `/shape-section` and `/sample-data` intentionally don't reference design-direction.md because they define WHAT the section does, not HOW it looks. Visual design is applied later by `/design-screen`.

### Fallback Behavior

If design-direction.md doesn't exist (user hasn't run `/design-shell`), commands behave as follows:

| Command           | Fallback Behavior                                                                                    |
| ----------------- | ---------------------------------------------------------------------------------------------------- |
| `/design-screen`  | Uses SKILL.md guidance or fallback design principles; applies defaults from `agents.md`              |
| `/export-product` | Skips copying design-direction.md; generated prompts still work but lack specific aesthetic guidance |

**Why this happens:**

- `/design-shell` is optional — users may start with sections before creating a shell
- The design-direction.md document provides _consistency_ but isn't _required_ for individual screen designs
- When missing, each screen design uses the skill file or fallback principles independently

**Recommendation:** Run `/design-shell` before `/design-screen` to establish aesthetic consistency across all sections.

### Exported To

The `/export-product` command copies this to `product-plan/design-system/design-direction.md` for implementation agents.

---

## Design System Scope

Design OS separates concerns between its own UI and the product being designed:

- **Design OS UI**: Always uses the stone/lime palette and DM Sans typography
- **Product Screen Designs**: Use the design tokens defined for the product (when available)
- **Shell**: Shell components are created with product design tokens during `/design-shell`, then used by `ScreenDesignPage` to preview the full app experience

---

## Shell Props Passthrough

When viewing screen designs in Design OS, `ScreenDesignPage.tsx` wraps them in AppShell. To ensure ALL shell features appear in preview (breadcrumbs, context selector, header actions, etc.), Design OS uses a **complete passthrough pattern**.

> **Note:** `ScreenDesignPage` uses iframe isolation for CSS encapsulation. The actual shell wrapping occurs in `ScreenDesignFullscreen` (the `/fullscreen` route), which calls `getShellProps()` and passes props to AppShell.

### How It Works

1. **Shell spec defines features** — `product/shell/spec.md` contains sections like `## Context Selector`, `## Breadcrumbs`, `## Header Actions`
2. **`getShellProps()` parses everything** — In `shell-loader.ts`, this function reads the spec and returns all props
3. **ScreenDesignPage spreads props** — `<AppShell {...shellProps}>` passes everything to the shell component
4. **No props left behind** — Whatever you define in the spec appears in preview automatically

### Adding New Shell Features

When you need a new feature in AppShell:

| Step | File              | Action                                         |
| ---- | ----------------- | ---------------------------------------------- |
| 1    | `shell-loader.ts` | Add type to `ShellProps` interface             |
| 2    | `shell-loader.ts` | Add parser function (e.g., `parseMyFeature()`) |
| 3    | `shell-loader.ts` | Include in `getShellProps()` return object     |
| 4    | `design-shell.md` | Document the new spec section format           |

**ScreenDesignPage needs NO changes** — props are passed through automatically.

### ShellProps Interface

The complete `ShellProps` interface (from `src/lib/shell-loader.ts`):

| Property             | Type                             | Source           | Description                             |
| -------------------- | -------------------------------- | ---------------- | --------------------------------------- |
| `categories`         | `NavigationCategory[]`           | ScreenDesignPage | Navigation menu structure               |
| `user`               | `UserConfig`                     | ScreenDesignPage | Current user profile                    |
| `contextSelector`    | `ContextSelectorConfig`          | spec.md          | Organization/client/workspace picker    |
| `breadcrumbs`        | `BreadcrumbItem[]`               | spec.md          | Navigation hierarchy paths              |
| `headerActions`      | `HeaderAction[]`                 | spec.md          | Header action buttons                   |
| `shellRelationships` | `ShellRelationship[]`            | spec.md          | Trigger-to-component mappings           |
| `sidebarCollapsed`   | `boolean`                        | User preference  | Sidebar collapse state                  |
| `layoutVariant`      | `'sidebar'\|'topnav'\|'minimal'` | spec.md          | Shell layout style                      |
| `currentSection`     | `string`                         | ScreenDesignPage | Active section ID                       |
| `currentView`        | `string`                         | ScreenDesignPage | Active view name                        |
| `[key: string]`      | `unknown`                        | spec.md          | Additional custom props (extensibility) |

> **Note:** The interface includes a catchall `[key: string]: unknown` allowing additional props from spec.md to pass through to AppShell. This enables custom shell features without modifying the interface.

### Shell Spec Sections

The following sections in `product/shell/spec.md` are parsed into ShellProps:

| Section                  | Prop                 | Description                                 |
| ------------------------ | -------------------- | ------------------------------------------- |
| `## Context Selector`    | `contextSelector`    | Organization/client/workspace picker        |
| `## Breadcrumbs`         | `breadcrumbs`        | Navigation hierarchy paths                  |
| `## Header Actions`      | `headerActions`      | Header action buttons                       |
| `## Layout Pattern`      | `layoutVariant`      | Shell layout style                          |
| `## Shell Relationships` | `shellRelationships` | Mapping of triggers to secondary components |

> **Note:** Props like `categories`, `user`, `currentSection`, and `currentView` are provided by ScreenDesignPage at runtime and are NOT parsed from spec.md.

### Secondary Component Passthrough

When viewing screen designs, ScreenDesignPage also manages secondary shell components:

1. **Shell relationships parsed** — `getShellProps()` parses `## Shell Relationships` from spec.md
2. **State managed in ScreenDesignPage** — State for each secondary component (isNotificationsOpen, etc.)
3. **Handlers wired** — onHeaderAction, onProfileClick, etc. update state
4. **Secondary components rendered** — Sheet/Dialog wrappers with actual components

> **Note:** These callbacks are NOT part of the base ShellProps interface from `shell-loader.ts`. They are added by ScreenDesignPage when rendering the shell wrapper. See `src/components/ScreenDesignPage.tsx` (ShellComponentProps interface) for the complete callback definitions.

**Key callbacks passed to AppShell:**

| Callback               | Purpose               | Wires To                       |
| ---------------------- | --------------------- | ------------------------------ |
| `onNavigate`           | Navigation link click | Preview console logging        |
| `onLogout`             | User logout action    | Preview console logging        |
| `onContextSelect`      | Context selector      | Preview console logging        |
| `onBreadcrumbClick`    | Breadcrumb navigation | Preview console logging        |
| `onHeaderAction`       | Header button clicks  | Opens drawer/modal by ID       |
| `onNotificationsClick` | Bell icon click       | `setIsNotificationsOpen(true)` |
| `onSearchClick`        | Search icon / Cmd+K   | `setIsSearchOpen(true)`        |
| `onHelpClick`          | Help icon click       | `setIsHelpOpen(true)`          |
| `onProfileClick`       | Profile menu item     | `setIsProfileOpen(true)`       |
| `onSettingsClick`      | Settings menu item    | `setIsSettingsOpen(true)`      |
| `onFeedbackClick`      | Feedback menu item    | `setIsFeedbackOpen(true)`      |
| `onMobileMenuToggle`   | Mobile hamburger menu | `setIsMobileMenuOpen(true)`    |

This ensures secondary shell components work in preview just like section view relationships.

### Example: Context Selector

**In `product/shell/spec.md`:**

```markdown
## Context Selector

type: organization
label: "Select Organization"
position: header-left
items:

- { id: "org-1", name: "Acme Corp", icon: "building" }
- { id: "org-2", name: "Globex Inc", icon: "building" }
```

**Automatically available in AppShell as:**

```typescript
props.contextSelector = {
  type: "organization",
  label: "Select Organization",
  position: "header-left",
  items: [
    { id: "org-1", name: "Acme Corp", icon: "building" },
    { id: "org-2", name: "Globex Inc", icon: "building" },
  ],
};
```

### Why This Pattern?

| Without Passthrough             | With Passthrough           |
| ------------------------------- | -------------------------- |
| Add prop to AppShell            | Add prop to AppShell       |
| Add to ScreenDesignPage         | _(no change needed)_       |
| Risk forgetting props           | Impossible to forget       |
| Maintenance grows with features | Maintenance stays constant |

---

## Export & Handoff

The `/export-product` command generates a complete handoff package:

- **Ready-to-use prompts**: Pre-written prompts to copy/paste into coding agents
  - `one-shot-prompt.md`: For full implementation in one session
  - `section-prompt.md`: Template for section-by-section implementation
- **Implementation instructions**: Detailed guides for each milestone
  - `product-overview.md`: Always provide for context
  - `one-shot-instructions.md`: All milestones combined
  - Incremental instructions in `instructions/incremental/`
- **Design guidance**: The frontend-design skill is copied to `design-guidance/frontend-design.md`
  - Provides guidance for creating distinctive, production-grade components
  - Ensures implementation agents follow the same quality standards
  - Referenced in prompts: "Read `product-plan/design-guidance/frontend-design.md` before creating components"
- **Test instructions**: Each section includes `tests.md` with TDD specs
- **Portable components**: Props-based, ready for any React setup

The prompts guide the implementation agent to ask clarifying questions about authentication, user modeling, and tech stack before building. Test instructions are framework-agnostic and include user flows, empty states, and edge cases.

---

## Template System

Design OS uses a modular template system for generating implementation prompts and instructions.

### Location

`.claude/templates/design-os/` contains:

- `common/` — Shared templates (top-rules, verification, TDD workflow)
- `one-shot/` — Full implementation prompt templates
- `section/` — Section-by-section prompt templates
- `README.md` — Complete template system documentation

### Template Versions

| Template                           | Version        | Notes                          |
| ---------------------------------- | -------------- | ------------------------------ |
| `common/top-rules.md`              | v1.0.0         | Core rules for implementation  |
| `common/reporting-protocol.md`     | v1.0.0         | Progress reporting format      |
| `common/model-guidance.md`         | v1.1.0         | Model behavior guidance        |
| `common/verification-checklist.md` | v1.0.0         | Final verification steps       |
| `common/clarifying-questions.md`   | v1.0.0         | Questions for foundation setup |
| `common/tdd-workflow.md`           | v1.1.0         | Test-driven development flow   |
| `one-shot/preamble.md`             | v1.1.0         | One-shot prompt intro          |
| `one-shot/prompt-template.md`      | v1.0.0         | One-shot file references       |
| `section/preamble.md`              | v1.1.0         | Section prompt intro           |
| `section/prompt-template.md`       | v1.0.0         | Section file references        |
| `section/clarifying-questions.md`  | v1.1.0-section | Section-specific questions     |
| `section/tdd-workflow.md`          | v1.2.0-section | Section-specific TDD           |

> **Version Format:** `v{major}.{minor}.{patch}[-suffix]`. The `-section` suffix indicates section-specific variants.

> **Maintenance Process:** When updating template files:
>
> 1. Bump version in template file header (e.g., `<!-- v1.0.1 -->`)
> 2. Update corresponding entry in this table
> 3. Run `grep -h "^<!-- v" .claude/templates/design-os/**/*.md` to verify all versions
> 4. Document changes in commit message

### Command Versions

Commands in `.claude/commands/design-os/` include version headers (`<!-- vX.X.X -->`) at the top of each file:

| Command              | Version | Notes                                                                                                                               |
| -------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `/product-interview` | v1.3.5  | + Warning behavior for --minimal --skip-validation, mid-interview correction, file write verification, completeness math validation |
| `/audit-context`     | v1.1.6  | + awk portability fix, output capture wrapper, category guards, Consistency Matrix clarification, variable scope notes              |
| `/product-vision`    | v1.0.0  | Initial stable version                                                                                                              |
| `/product-roadmap`   | v1.0.0  | Initial stable version                                                                                                              |
| `/data-model`        | v1.0.0  | Initial stable version                                                                                                              |
| `/design-tokens`     | v1.0.0  | Initial stable version                                                                                                              |
| `/design-shell`      | v1.0.0  | Initial stable version                                                                                                              |
| `/shape-section`     | v1.0.0  | Initial stable version                                                                                                              |
| `/sample-data`       | v1.0.0  | Initial stable version                                                                                                              |
| `/design-screen`     | v1.0.0  | Initial stable version                                                                                                              |
| `/screenshot-design` | v1.0.0  | Initial stable version                                                                                                              |
| `/export-product`    | v1.0.0  | Initial stable version                                                                                                              |

> **Maintenance Note:** When updating a command, bump its version and update this table. Use semantic versioning: patch for fixes, minor for features, major for breaking changes.

### Usage

The `/export-product` command assembles these templates (see Step 14: Generate Prompt Files) into ready-to-use prompts:

- `product-plan/prompts/one-shot-prompt.md`
- `product-plan/prompts/section-prompt.md`

See `.claude/templates/design-os/README.md` for template authoring and assembly details.

### Foundation Milestone Definition

The "Foundation" milestone (milestone 01) includes core infrastructure that all sections depend on:

1. **Project Setup**: Package.json, build config, linting, TypeScript configuration
2. **Authentication**: Auth provider integration, protected routes, session management
3. **Core Layout**: Shell components (AppShell, MainNav, UserMenu) — **CONDITIONAL** (see Shell Conditional Logic below)
4. **Design System**: Theme provider, color tokens, typography classes
5. **Routing**: Router setup, navigation structure, route guards
6. **Data Layer**: API client setup, state management, data fetching patterns

> **Shell Conditional Logic:** During `/export-product` Step 1, if shell components don't exist or user chooses to proceed without shell, `INCLUDE_SHELL=false` is set. This flag affects:
>
> | INCLUDE_SHELL | 01-foundation.md         | product-plan/shell/ | Implementation Notes                 |
> | ------------- | ------------------------ | ------------------- | ------------------------------------ |
> | `true`        | Includes shell setup     | Created with files  | Use provided AppShell, MainNav, etc. |
> | `false`       | Skips shell instructions | Not created         | Build custom navigation from scratch |

**In exports:** Foundation is always `instructions/incremental/01-foundation.md`. Section milestones start at `02-[section-id].md`.

**In TDD workflow:** Foundation tests should be written and passing before implementing any section features. These tests cover routing, authentication, and the data layer.

---

## Design System (Design OS Application)

The Design OS application itself uses a "Refined Utility" aesthetic:

- **Typography**: DM Sans for headings and body, IBM Plex Mono for code
- **Colors**: Stone palette for neutrals (warm grays), lime for accents
- **Layout**: Maximum 800px content width, generous whitespace
- **Cards**: Minimal borders (1px), subtle shadows, generous padding
- **Motion**: Subtle fade-ins (200ms), no bouncy animations

### Icon Stroke Width Convention

Lucide React icons use intentionally varied stroke widths for visual hierarchy:

| Stroke Width      | Use Case                                      | Examples                                  |
| ----------------- | --------------------------------------------- | ----------------------------------------- |
| **1.5** (default) | Standard icons, navigation, actions           | ArrowLeft, ChevronRight, Layout, Download |
| **2**             | Smaller icons (w-3/w-4), interactive elements | X button, GripVertical, AlertTriangle     |
| **2.5**           | Status indicators, emphasis, completion marks | Check marks, Step indicators              |
| **3**             | Tiny icons (w-2.5), maximum visibility        | Tiny check marks in checkboxes            |

**Rationale:**

- Thinner strokes (1.5) for larger icons maintain visual balance
- Thicker strokes (2-3) for smaller icons ensure visibility and legibility
- Status icons use heavier weights to draw attention

**Example Usage:**

```tsx
// Standard 5x5 icon - use 1.5
<Layout className="w-5 h-5" strokeWidth={1.5} />

// Small 4x4 icon in button - use 2
<X className="w-4 h-4" strokeWidth={2} />

// Status indicator - use 2.5
<Check className="w-3.5 h-3.5" strokeWidth={2.5} />

// Tiny checkbox mark - use 3
<Check className="w-2.5 h-2.5" strokeWidth={3} />
```

This pattern is intentional and should NOT be normalized to a single value.

---

## Product Context System

The `/product-interview` command creates `product/product-context.md`, which serves as the central source of truth for all Design OS commands.

### Why Product Context is Required

Before `/product-interview`, users often encountered these problems:

- **Incomplete designs** — Missing error states, loading states, edge cases
- **Inconsistent decisions** — Different assumptions across sections
- **Repeated questions** — Same clarifications asked in multiple commands
- **Design gaps** — Accessibility, mobile patterns, or performance considerations overlooked

Product context solves this by gathering comprehensive information upfront.

### Context Categories

| #   | Category                 | Qty | Topics                                                                       | Used By Commands                                    |
| --- | ------------------------ | --- | ---------------------------------------------------------------------------- | --------------------------------------------------- |
| 1   | Product Foundation       | 6   | Target audience, problem space, competitors, success metrics, business model | `/product-vision`, `/product-roadmap`               |
| 2   | User Research & Personas | 4   | Personas, accessibility needs, geographic distribution                       | `/product-vision`, `/design-shell`                  |
| 3   | Design Direction         | 5   | Aesthetic tone, animation, density, brand constraints                        | `/design-tokens`, `/design-shell`, `/design-screen` |
| 4   | Data Architecture        | 5   | Sensitivity, compliance, relationships, audit needs                          | `/data-model`, `/sample-data`                       |
| 5   | Section-Specific Depth   | 5   | User flows, edge cases, empty/loading/error states                           | `/shape-section`, `/sample-data`, `/design-screen`  |
| 6   | UI Patterns & Components | 5   | Data display, validation, notifications, confirmations                       | `/shape-section`, `/design-screen`                  |
| 7   | Mobile & Responsive      | 4   | Priority, touch interactions, navigation, offline                            | `/design-shell`, `/design-screen`                   |
| 8   | Performance & Scale      | 4   | User volume, data scale, real-time needs, search                             | `/product-roadmap`, `/shape-section`                |
| 9   | Integration Points       | 3   | Auth provider, external services, API exposure                               | `/design-shell`, `/export-product`                  |
| 10  | Security & Compliance    | 3   | Auth level, authorization model, audit logging                               | `/data-model`, `/export-product`                    |
| 11  | Error Handling           | 4   | Message style, retry behavior, undo/redo, data loss prevention               | `/shape-section`, `/design-screen`                  |
| 12  | Testing & Quality        | 4   | Coverage targets, E2E scope, accessibility testing, browser support          | `/export-product`                                   |

**Total:** 52 questions (~45-60 min for full interview, ~20-30 min for `--minimal`)

### Completeness Requirements

Commands require minimum 50% completeness to proceed:

```markdown
Completeness Calculation:

- 12 total categories
- Each category status: ✅ Complete (all questions) / ⚠️ Partial (some) / ❌ Empty
- Overall = (count of ✅ Complete categories ÷ 12) × 100
- Minimum threshold: 50% (6+ categories fully complete)
```

> **Note:** Only ✅ Complete categories count toward the percentage. ⚠️ Partial categories do not increase completeness—they need to be finished.

**Behavior by completeness:**

| Completeness | Behavior                                                         |
| ------------ | ---------------------------------------------------------------- |
| 0% (missing) | ERROR: "Run /product-interview first"                            |
| 1-49%        | WARNING: "Context incomplete (X%). Continue or interview first?" |
| 50-74%       | PROCEED: Load context, note missing categories                   |
| 75-100%      | PROCEED: Full context available                                  |

### Quick Start with --minimal

For users who want to start quickly:

```bash
/product-interview --minimal
```

This covers 6 critical categories (1, 3, 5, 6, 7, 11) and takes ~29 questions instead of ~52. This meets the 50% completeness threshold required by other commands.

**Why these categories?**

| Category                     | Why Critical                                                                |
| ---------------------------- | --------------------------------------------------------------------------- |
| 1 (Product Foundation)       | Product name, audience, problem — needed for `/product-vision`              |
| 3 (Design Direction)         | Aesthetic tone, density — needed for `/design-tokens` and all visual design |
| 5 (Section-Specific Depth)   | User flows, states — needed for `/shape-section` and `/design-screen`       |
| 6 (UI Patterns & Components) | Component preferences — needed for all screen designs                       |
| 7 (Mobile & Responsive)      | Responsive strategy — needed for `/design-shell` and all screen designs     |
| 11 (Error Handling)          | Error states — needed for complete, production-ready designs                |

These 6 categories provide minimum viable context (50%) for the design workflow. You can always run `--stage=X` later to fill in gaps.

**Why other categories are excluded from `--minimal`:**

| Category Excluded            | Reason                                                                                       |
| ---------------------------- | -------------------------------------------------------------------------------------------- |
| 2 (User Research & Personas) | Helpful but not blocking — designs can proceed with basic audience understanding             |
| 4 (Data Architecture)        | Implementation detail — can be defined during `/data-model` when needed                      |
| 8 (Performance & Scale)      | Implementation concern — relevant at export/implementation phase, not design                 |
| 9 (Integration Points)       | Implementation detail — auth/API specifics defined during implementation                     |
| 10 (Security & Compliance)   | Implementation phase — security details typically defined by implementation team, not design |
| 12 (Testing & Quality)       | Implementation phase — testing strategy defined when actually writing tests                  |

These categories enhance the design but aren't required for the visual design workflow. They become relevant during `/export-product` and implementation.

### Updating Context

To add missing sections or update existing answers:

```bash
/product-interview              # Will detect existing and offer to complete
/product-interview --stage=X    # Focus on specific area
/product-interview --audit      # Check what's missing
```

### Context File Location

`product/product-context.md` — Committed to repository, shared with team, referenced by all commands.

---

## Standardized Prerequisite Checks

All commands must follow this consistent pattern for checking prerequisites:

### Pattern: Required vs. Optional Prerequisites

**Required Prerequisites** → STOP with clear error message if missing

- **Product context** (all commands except `/product-interview`)
- Product overview (almost all commands)
- Product roadmap (planning commands)
- Section spec (for data/design commands)

**Optional Enhancements** → WARN and continue if missing

- Design tokens (design commands proceed with defaults)
- Data model (sample-data proceeds with local definitions)
- Application shell (design-shell question may be skipped)

> **See also:** For the complete list of Required and Optional prerequisites per command, refer to the **Command Prerequisites** table in the "Command Quick Reference" section above.

### Product Scope Persistence

Product scope (MVP/Standard/Enterprise) is determined by `/product-vision` and persisted in `product/product-overview.md`:

- `/product-vision` writes the scope using the format: `**Scope Level:** [MVP|Standard|Enterprise]`
- Commands that read scope should look for this exact pattern
- If not found, default to "Standard"

> **Canonical Format:** Always use `**Scope Level:**` (not `**Scope:**`). This ensures consistent parsing across all commands.

| Scope          | Section Complexity | Feature Suggestions                              |
| -------------- | ------------------ | ------------------------------------------------ |
| **MVP**        | Core features only | Minimal views (1-2), essential actions           |
| **Standard**   | Full feature set   | Multiple views (2-4), common patterns            |
| **Enterprise** | Comprehensive      | All views, advanced features, admin capabilities |

**Commands that read scope:** `/shape-section`

> **Note:** `/sample-data` uses data volume preferences (Step 3.5) rather than product scope. The scope primarily affects section complexity during `/shape-section`.

### Standard Error Messages

**Required file missing:**

```
I don't see [file description] at [path]. Please run [prerequisite command] first.
```

**Optional feature missing:**

```
Note: [Feature] hasn't been defined yet. I'll proceed with [default approach], but for [reason], consider running [command] first.
```

### Error Message Format Standard

All commands must use consistent error message formatting:

**Pattern:** `Error: [Component] - [Issue]. [Action to fix].`

**Examples:**

| Component           | Issue                  | Action                       | Full Message                                                                                          |
| ------------------- | ---------------------- | ---------------------------- | ----------------------------------------------------------------------------------------------------- |
| product-overview.md | File not found         | Run /product-vision          | `Error: product-overview.md - File not found. Run /product-vision to create it.`                      |
| data.json           | Invalid JSON syntax    | Check file for syntax errors | `Error: data.json - Invalid JSON syntax. Check the file for missing commas or brackets.`              |
| AppShell.tsx        | Missing default export | Add export default statement | `Error: AppShell.tsx - Missing default export. Add 'export default AppShell' at the end of the file.` |
| SKILL.md            | Insufficient content   | Add design guidance          | `Error: SKILL.md - Insufficient content (< 100 chars). Add meaningful design guidance.`               |

**Severity Levels:**

| Level   | Prefix     | Behavior                            |
| ------- | ---------- | ----------------------------------- |
| Error   | `Error:`   | STOP command, require user action   |
| Warning | `Warning:` | Continue with fallback, inform user |
| Note    | `Note:`    | Informational, no action required   |

**Format Consistency:**

- Always start with the level prefix (`Error:`, `Warning:`, `Note:`)
- Include the component/file name after the prefix
- Use a hyphen to separate the component from the issue
- End with a clear action the user can take
- Use periods to terminate sentences

This ensures users can quickly understand what went wrong and how to fix it.

### Directory Creation Pattern

All commands that create files must include explicit directory creation:

```bash
# Before creating /product/sections/[section-id]/spec.md:
mkdir -p product/sections/[section-id]

# Before creating /product/design-system/colors.json:
mkdir -p product/design-system

# Before creating src/shell/components/AppShell.tsx:
mkdir -p src/shell/components
```

**Commands and Required Directories:**

| Command              | Directory to Create                                            |
| -------------------- | -------------------------------------------------------------- |
| `/product-interview` | `mkdir -p product/`                                            |
| `/product-vision`    | `mkdir -p product/`                                            |
| `/product-roadmap`   | `mkdir -p product/`                                            |
| `/data-model`        | `mkdir -p product/data-model/`                                 |
| `/design-tokens`     | `mkdir -p product/design-system/`                              |
| `/shape-section`     | `mkdir -p product/sections/[section-id]/`                      |
| `/sample-data`       | (Directory already exists from /shape-section)                 |
| `/design-shell`      | `mkdir -p product/shell/` and `mkdir -p src/shell/components/` |
| `/design-screen`     | `mkdir -p src/sections/[section-id]/components/`               |
| `/export-product`    | `mkdir -p product-plan/` and subdirectories                    |

> **Note on .gitkeep files:** Empty directories in the boilerplate contain `.gitkeep` placeholder files to ensure Git tracks them. When commands create files in these directories, the `.gitkeep` can remain (harmless) or be removed. Never reference `.gitkeep` in code — treat directories as empty until populated by commands.

### File Validation Pattern

After creating critical files, verify structure:

1. **Check existence:** File was actually written
2. **Validate structure:** Required fields/sections exist
3. **Verify content:** Data is consistent and complete

For `data.json` files specifically:

- Verify `_meta` object exists at top level
- Verify `_meta.models` is an object with descriptions
- Verify `_meta.relationships` is an array
- Ensure all model names match actual data keys

### Recovery Pattern (If Steps Fail)

Commands should provide recovery guidance when critical steps fail:

**Quick Recovery Notes (for inline use):**

```markdown
> **Recovery:** If this step fails, [specific action]. Check [what to check].
```

**Standard Recovery Actions:**

| Failure Type        | Recovery Action                                      |
| ------------------- | ---------------------------------------------------- |
| File creation fails | Check write permissions: `ls -la [parent-dir]/`      |
| Directory missing   | Create directory: `mkdir -p [path]`                  |
| Validation fails    | Review error message, fix issues, re-run step        |
| JSON parse error    | Validate syntax: paste content into a JSON validator |
| Import error        | Check file exists and path is correct                |

**Command Recovery Quick Reference:**

| Command           | Common Failure         | Recovery Action                                     |
| ----------------- | ---------------------- | --------------------------------------------------- |
| `/product-vision` | File write fails       | Check permissions: `ls -la product/`                |
| `/design-shell`   | Component import error | Verify UI components exist: `ls src/components/ui/` |
| `/design-screen`  | Skill file missing     | Proceed with fallback or add SKILL.md               |
| `/sample-data`    | JSON validation fails  | Fix syntax errors in data.json and retry            |
| `/export-product` | Template missing       | Re-clone boilerplate from source repository         |

**Full Recovery Section (for complex commands):**

For commands with multiple steps that can fail (like `/export-product`), include a dedicated "Rollback / Recovery" section at the end covering:

1. Pre-command backups (if applicable)
2. Partial failure cleanup
3. Resume instructions
4. Git-based recovery options

**Commands with dedicated recovery sections:**

- `/export-product` — Full rollback/recovery section (Step 15)
- `/sample-data` — Recovery Pattern section at end of file

**Commands with inline recovery notes:**

All commands that create or modify files should include brief `> **Recovery:**` notes for critical file operations. Priority commands:

| Command              | Critical Operations                    | Recovery Note Location         |
| -------------------- | -------------------------------------- | ------------------------------ |
| `/screenshot-design` | Dev server startup, screenshot capture | Steps 3, 4, 5 (already added)  |
| `/design-shell`      | Component creation, spec generation    | After Step 7 (component write) |
| `/design-screen`     | Component creation, preview generation | After Step 5 (component write) |
| `/shape-section`     | Spec file creation                     | After Step 7 (spec write)      |
| `/design-tokens`     | JSON file creation                     | After token file write         |
| `/product-vision`    | Overview file creation                 | After overview write           |
| `/product-roadmap`   | Roadmap file creation                  | After roadmap write            |
| `/data-model`        | Data model file creation               | After data-model write         |

> **Note:** Commands like `/product-interview` and `/audit-context` are primarily read/analyze operations and don't require recovery notes unless they write files.

### Section ID Generation Rules

> **Single Source of Truth:** These rules are the authoritative definition. Other commands (`/shape-section`, `/product-roadmap`) should reference this section rather than duplicating the rules.

When creating section IDs from section titles, follow these standardized rules:

1. **Convert to lowercase** — "Invoice Management" → "invoice management"
2. **Replace spaces with hyphens** — "invoice management" → "invoice-management"
3. **Replace "&" with "-and-"** — "Reports & Analytics" → "reports-and-analytics"
4. **Remove special characters except hyphens** — Strip punctuation, quotes, etc.
5. **Remove diacritics** — "Café Management" → "cafe-management", "Señor" → "senor"
6. **Collapse consecutive hyphens** — "reports--and" → "reports-and" (multiple spaces or special chars become single hyphen)
7. **Cannot start or end with hyphen** — Trim leading/trailing hyphens
8. **Maximum 50 characters** — Truncate if necessary

**Examples:**

- "Invoice Management" → `invoice-management`
- "Reports & Analytics" → `reports-and-analytics`
- "User Settings" → `user-settings`
- "Q&A Forum" → `q-and-a-forum`

This ensures consistent path naming across all commands that reference sections.

### Variable Naming Conventions

Commands use two distinct variable notation styles for different contexts:

| Notation          | Context                            | Example                                 |
| ----------------- | ---------------------------------- | --------------------------------------- |
| `[variable-name]` | Placeholder in documentation/paths | `product/sections/[section-id]/spec.md` |
| `VARIABLE_NAME`   | Bash variable in scripts           | `SECTION_ID=$(echo "$path" \| sed ...)` |

**When to use each:**

- **Brackets `[...]`** — Use in documentation, file paths, and templates where the value will be substituted by the reader/user
- **Uppercase** — Use in bash scripts where the value is assigned and referenced programmatically

**Example transformation:**

```markdown
# Documentation (placeholder)

The spec is at: product/sections/[section-id]/spec.md

# Bash script (variable)

SECTION_ID="invoices"
SPEC_PATH="product/sections/${SECTION_ID}/spec.md"
```

**Common variables:**

| Placeholder      | Bash Variable  | Description                              |
| ---------------- | -------------- | ---------------------------------------- |
| `[section-id]`   | `SECTION_ID`   | Section folder name (e.g., `invoices`)   |
| `[view-name]`    | `VIEW_NAME`    | Screen design name (e.g., `InvoiceList`) |
| `[product-name]` | `PRODUCT_NAME` | Product name from overview               |

**Bash Variable Syntax (`$VAR` vs `${VAR}`):**

Both notations are valid bash syntax. Use `${VAR}` (braces) when:

- Variable is followed by characters that could be part of the name: `${SECTION_ID}_backup`
- Inside strings for clarity: `"path/${SECTION_ID}/file.md"`
- Recommended for consistency in new code

Use `$VAR` (no braces) when:

- Variable stands alone: `echo $SECTION_ID`
- In simple assignments: `NEW_VAR=$OLD_VAR`

> **Note:** Existing code may use either notation. Both work correctly — this is a style preference, not a requirement.

### Question Asking Patterns

Commands should ask users questions in a consistent, predictable way:

**Question Format:**

```markdown
**[Category]:**

1. [Specific question]?
2. [Another specific question]?
```

**Categories by Command Type:**

| Command Type    | Typical Questions                                      |
| --------------- | ------------------------------------------------------ |
| Vision/Planning | Product goals, target audience, key differentiators    |
| Data Model      | Entity relationships, required vs. optional fields     |
| Design          | Color preferences, layout style, responsive priorities |
| Section         | Feature scope, edge cases, integration points          |
| Export          | Target framework, authentication approach, deployment  |

**Question Timing:**

| When                  | Question Pattern                     |
| --------------------- | ------------------------------------ |
| Before starting       | Clarify ambiguous requirements       |
| At decision points    | Offer options with recommendations   |
| On validation failure | Explain issue and ask how to proceed |
| Before overwriting    | Confirm destructive operations       |

**Answer Handling:**

1. Accept short answers (yes/no, option letters, brief phrases)
2. Provide sensible defaults when possible
3. Don't re-ask questions already answered in conversation context
4. Document decisions made for future reference

### Retry Pattern (Standardized)

Commands that involve validation loops should follow this consistent retry pattern:

**Retry Tracking Format:**

```
[Attempt 1/3] Validating [component]...
[Attempt 2/3] Validating [component]...
[Attempt 3/3 - FINAL] Validating [component]...
```

**Retry Behavior:**

| Attempt     | Action                                                         |
| ----------- | -------------------------------------------------------------- |
| 1/3         | Run validation, report errors, offer fix guidance              |
| 2/3         | Re-validate after user fixes, report remaining errors          |
| 3/3 - FINAL | Last attempt, fail with complete error summary if unsuccessful |

**Commands and Retry Pattern Status:**

| Command           | Validation Type                      | Implements Retry?              |
| ----------------- | ------------------------------------ | ------------------------------ |
| `/sample-data`    | JSON structure, \_meta validation    | YES (3 attempts)               |
| `/design-tokens`  | Font availability, weight validation | SHOULD add                     |
| `/design-screen`  | Component import, props validation   | SHOULD add                     |
| `/export-product` | Template, component validation       | Complex — uses manual recovery |

> **Note:** Commands marked "SHOULD add" would benefit from retry logic for consistency. Currently they fail on first validation error.

**Why different approaches?**

| Approach           | Reason                                                 | Commands                           |
| ------------------ | ------------------------------------------------------ | ---------------------------------- |
| Retry (3 attempts) | Iterative fixes needed for structured data validation  | `/sample-data`                     |
| Fail fast          | Visual output makes issues immediately obvious         | `/design-screen`, `/design-tokens` |
| Manual recovery    | Multi-step process where issues can occur at any point | `/export-product`                  |

Commands without retry patterns are lower priority because their errors are either immediately visible (visual components) or rare (font validation).

**After 3 failed attempts:**

```
Error: Validation failed after 3 attempts.
Please review the errors above and fix manually before retrying.
```

### Viewport Dimensions (Standardized)

All commands referencing viewport sizes must use these consistent dimensions:

| Viewport          | Width  | Height | Use Case                                |
| ----------------- | ------ | ------ | --------------------------------------- |
| Desktop (default) | 1280px | 800px  | Standard documentation, screenshots     |
| Mobile            | 375px  | 667px  | Mobile-first testing, responsive checks |
| Tablet            | 768px  | 1024px | Tablet variants, medium breakpoints     |

**Responsive Breakpoints:**

| Breakpoint | Width Range | Tailwind Class |
| ---------- | ----------- | -------------- |
| Mobile     | < 640px     | (default)      |
| Tablet     | 640-1024px  | `sm:`, `md:`   |
| Desktop    | > 1024px    | `lg:`, `xl:`   |

**Command-Specific Usage:**

| Command              | Viewport Usage                                               |
| -------------------- | ------------------------------------------------------------ |
| `/screenshot-design` | Desktop 1280x800 default, capture all viewports as needed    |
| `/design-screen`     | Build mobile-first, test at all breakpoints                  |
| `/design-shell`      | Design for all breakpoints, desktop is primary layout        |
| `/export-product`    | Verification checklist includes 375px, 768px, 1024px, 1920px |

**Responsive Strategy Clarification:**

> **TL;DR:** Shell = desktop-first (start with sidebar, add hamburger for mobile). Sections = mobile-first (start with single column, add grid for desktop). Both work at all breakpoints.

| Component | Strategy      | Why                                | Start With    | Enhance For        |
| --------- | ------------- | ---------------------------------- | ------------- | ------------------ |
| Shell     | Desktop-first | Navigation optimized for desktop   | Full sidebar  | Hamburger (mobile) |
| Sections  | Mobile-first  | Content must work on small screens | Single column | Grid (desktop)     |

The shell and section components use different responsive approaches:

- **Shell components (`/design-shell`):** Desktop-first because navigation chrome is optimized for desktop use; mobile gets a simplified drawer/hamburger menu
- **Section components (`/design-screen`):** Mobile-first because content should work on small screens and enhance for larger ones

Both must work at all breakpoints. The difference is which layout is designed first and enhanced for other sizes.

**Reconciling Both Strategies:**

Both strategies coexist because they serve different purposes:

1. **Shell (Desktop-first):**
   - Start with full sidebar navigation layout
   - Add `md:hidden` to desktop nav, show hamburger menu on mobile
   - Main content area uses responsive `w-full` container

2. **Sections (Mobile-first):**
   - Start with single-column mobile layout (stack cards vertically)
   - Add `sm:grid-cols-2`, `lg:grid-cols-3` for larger screens
   - Shell already handles navigation; sections focus on content

**Breakpoint Ownership:**

| Element  | Owns Breakpoint Logic For                                     |
| -------- | ------------------------------------------------------------- |
| Shell    | Navigation visibility, sidebar collapse/expand, header layout |
| Sections | Content layout, card grids, data table columns, form layouts  |

**Breakpoint Ownership by Size:**

| Breakpoint  | Width Range | Shell Owns                            | Section Owns                           |
| ----------- | ----------- | ------------------------------------- | -------------------------------------- |
| **Mobile**  | < 640px     | Hamburger menu, hidden sidebar        | Single column, stacked cards           |
| **Tablet**  | 640-1024px  | Collapsible sidebar, condensed header | 2-column grids, responsive tables      |
| **Desktop** | > 1024px    | Full sidebar, expanded header actions | Multi-column layouts, full data tables |

**Conflict Resolution:**

At intermediate breakpoints (e.g., 768px):

- Shell's sidebar state takes precedence for layout width calculations
- Sections should use `flex-1` or `w-full` to fill available space
- Never hardcode section widths that assume sidebar visibility

This separation means changes to mobile navigation don't affect section layouts, and vice versa.

**Screenshot Naming Convention:**

```
[view-name].png           # Desktop (default)
[view-name]-mobile.png    # Mobile viewport
[view-name]-tablet.png    # Tablet viewport
[view-name]-dark.png      # Dark mode variant
```

---

## Shell Utility Components

Utility components and hooks available in `src/shell/` for building shell features. Used by `/design-shell` audit checklist (sections I-L).

> **Note:** These utility components are **pre-existing** in the boilerplate. They are distinct from the **secondary components** (NotificationsDrawer, SearchModal, SettingsModal, ProfileModal, etc.) which are **generated** by `/design-shell` based on user selections. The utility components provide accessibility, error handling, and loading states; the secondary components provide interactive shell features.

**Components (`src/shell/components/`):**

| Component            | Priority | Purpose                                 |
| -------------------- | -------- | --------------------------------------- |
| `SkipLink`           | High     | Skip-to-content accessibility link      |
| `ShellErrorBoundary` | High     | Error boundary for secondary components |
| `LogoArea`           | Medium   | Customizable logo/branding area         |
| `ThemeToggle`        | Medium   | Light/dark/system theme switcher        |
| `ShellSkeleton`      | Medium   | Loading skeleton states                 |
| `ShellFooter`        | Low      | Optional footer with version/links      |

**Hooks (`src/shell/hooks/`):**

| Hook                 | Priority | Purpose                                   |
| -------------------- | -------- | ----------------------------------------- |
| `useFocusManagement` | High     | Focus trap and restoration for modals     |
| `useShellShortcuts`  | Medium   | Global keyboard shortcuts (Cmd+K, etc.)   |
| `useShellState`      | Medium   | Persistent UI state (sidebar, nav groups) |
| `useSessionTimeout`  | Low      | Session inactivity timeout with warning   |

**Usage:**

```tsx
import { SkipLink, ShellErrorBoundary, ThemeToggle } from "@/shell/components";

import {
  useFocusManagement,
  useShellShortcuts,
  useShellState,
} from "@/shell/hooks";
```

---

## Template State (Boilerplate Directories)

The Design OS boilerplate includes several intentionally empty directories. This is by design — they serve as placeholders that users populate through the Design OS workflow commands.

### Intentionally Empty Directories

| Directory                | Purpose                            | Populated By                                                           |
| ------------------------ | ---------------------------------- | ---------------------------------------------------------------------- |
| `product/`               | Product definition files           | `/product-vision`, `/product-roadmap`, `/data-model`, `/design-tokens` |
| `product/sections/`      | Section specifications and data    | `/shape-section`, `/sample-data`                                       |
| `product/shell/`         | Shell specification                | `/design-shell`                                                        |
| `product/design-system/` | Design tokens (colors, typography) | `/design-tokens`, `/design-shell` (design-direction.md)                |
| `product/data-model/`    | Global data model                  | `/data-model`                                                          |
| `src/shell/components/`  | Shell primary/secondary components | `/design-shell` (adds to pre-existing utility components)              |
| `src/sections/`          | Section screen design components   | `/design-screen`                                                       |
| `product-plan/`          | Export package (generated)         | `/export-product`                                                      |

> **Note:** Subdirectories within sections (e.g., `product/sections/[id]/`, `src/sections/[id]/components/`) are also initially empty and created by their respective commands.

### Why Empty?

1. **Clean starting point** — Users begin with a blank canvas, not outdated example content
2. **No confusion** — Example content could be mistaken for required structure
3. **Workflow-driven** — Each directory is populated through its corresponding command
4. **Portable** — The boilerplate works for any product type without modification

### The .gitkeep Convention

Empty directories contain a `.gitkeep` file to ensure they're tracked by Git. This is a common convention since Git doesn't track empty directories.

**Important:**

- `.gitkeep` files are placeholders only — they have no special meaning to Git
- When a command creates files in the directory, the `.gitkeep` can remain (harmless)
- Never reference `.gitkeep` in code or commands — treat directories as empty until populated
- These files are intentionally excluded from exports and sync operations

### Helper Functions

The Design OS source code includes functions that check for content existence:

- `hasShellComponents()` — Returns `false` until `/design-shell` creates shell components
- `hasShellSpec()` — Returns `false` until `/design-shell` creates `product/shell/spec.md`
- `loadProductData()` — Returns empty/null values until product files are created

These functions gracefully handle the empty state and enable the UI to show appropriate "get started" messaging rather than errors.

---

## Hookify Guardrails

Design OS includes **hookify rules** that provide real-time feedback during development. These rules catch common mistakes before they cause problems.

### How It Works

Hookify rules are markdown files with YAML frontmatter that trigger on specific events:

- **file** events — When creating or editing files
- **prompt** events — When user submits a prompt
- **bash** events — When running bash commands

Each rule can either:

- **warn** — Show a warning and continue
- **block** — Prevent the action entirely

### Rule Categories

| Category       | Prefix           | Count | Purpose                                |
| -------------- | ---------------- | ----- | -------------------------------------- |
| Code Patterns  | `dos-code-`      | 6     | Prevent code that won't work correctly |
| Workflow       | `dos-workflow-`  | 3     | Guide command sequence                 |
| Data Integrity | `dos-data-`      | 4     | Ensure data.json correctness           |
| Design System  | `dos-design-`    | 4     | Enforce design consistency             |
| Accessibility  | `dos-a11y-`      | 2     | Catch accessibility issues             |
| File Structure | `dos-structure-` | 3     | Ensure correct file organization       |

**Total: 22 rules (3 BLOCK + 19 WARN)**

### Critical Rules (BLOCK)

These rules **prevent** actions that would break Design OS:

| Rule                                 | What It Blocks                                  |
| ------------------------------------ | ----------------------------------------------- |
| `dos-code-block-direct-data-import`  | Importing data.json in exportable components    |
| `dos-code-block-tailwind-config`     | Creating tailwind.config.js (v4 doesn't use it) |
| `dos-structure-block-tsx-in-product` | Creating .tsx files in product/ directory       |

### Managing Rules

**List all rules:**

```bash
ls .claude/hookify.dos-*.local.md
```

**Disable a rule:**

1. Open the rule file
2. Change `enabled: true` to `enabled: false`
3. Save — takes effect immediately

**Enable a disabled rule:**

1. Open the rule file
2. Change `enabled: false` to `enabled: true`
3. Save — takes effect immediately

### Full Documentation

See `.claude/hookify/README.md` for the complete hookify system documentation, including:

- Complete list of all rules organized by category
- Rule file format and condition operators
- Creating custom rules
- Troubleshooting guide

See `.claude/hookify/categories.md` for the category taxonomy and rule organization patterns.

Individual rule files (`.claude/hookify.*.local.md`) contain:

- Rule purpose and trigger conditions
- Match patterns and file filters
- Action type (warn or block)
- Enabled/disabled status
